/*\n实现一个瀑布流布局的组件，支持自动填充列数，并根据数据源动态生成不同大小和颜色的子项。\n*/\n\n// 导入自定义的WaterFlowDataSource类，用于提供数据源\nimport { WaterFlowDataSource } from './WaterFlowDataSource'\n\n// 定义入口组件WaterFlowDemo\n@Entry\n@Component\nstruct WaterFlowDemo {\n  // 定义状态变量minSize，表示子项的最小尺寸\n  @State minSize: number = 80\n  // 定义状态变量maxSize，表示子项的最大尺寸\n  @State maxSize: number = 180\n  // 定义状态变量colors，表示子项的背景颜色数组\n  @State colors: number[] = [0xFFC0CB, 0xDA70D6, 0x6B8E23, 0x6A5ACD, 0x00FFFF, 0x00FF7F]\n  // 定义数据源对象\n  dataSource: WaterFlowDataSource = new WaterFlowDataSource()\n  // 定义私有变量itemWidthArray，用于存储子项的宽度\n  private itemWidthArray: number[] = []\n  // 定义私有变量itemHeightArray，用于存储子项的高度\n  private itemHeightArray: number[] = []\n\n  // 定义获取随机尺寸的方法\n  getSize() {\n    // 生成一个介于0和maxSize之间的随机数\n    let ret = Math.floor(Math.random() * this.maxSize)\n    // 如果随机数小于minSize，则返回minSize，否则返回随机数\n    return (ret > this.minSize ? ret : this.minSize)\n  }\n\n  // 定义设置子项尺寸数组的方法\n  setItemSizeArray() {\n    // 循环100次，生成100个子项的宽度和高度\n    for (let i = 0; i < 100; i++) {\n      this.itemWidthArray.push(this.getSize())\n      this.itemHeightArray.push(this.getSize())\n    }\n  }\n\n  // 组件即将显示时调用的方法\n  aboutToAppear() {\n    // 调用设置子项尺寸数组的方法\n    this.setItemSizeArray()\n  }\n\n  // 构建组件的方法\n  build() {\n    // 使用Column布局，设置子项之间的间距为2\n    Column({ space: 2 }) {\n      // 使用WaterFlow布局\n      WaterFlow() {\n        // 使用LazyForEach遍历数据源，生成子项\n        LazyForEach(this.dataSource, (item: number) => {\n          // 使用FlowItem组件\n          FlowItem() {\n            // 使用Column布局\n            Column() {\n              // 显示文本，内容为"N"加上数据源中的item值\n              Text("N" + item).fontSize(12).height('16')\n              // 显示图片，图片路径为res/waterFlowTest(item % 5).jpg\n              Image('res/waterFlowTest(' + item % 5 + ').jpg')\n            }\n          }\n          // 设置子项的宽度为100%\n          .width('100%')\n          // 设置子项的高度为itemHeightArray中对应索引的值\n          .height(this.itemHeightArray[item % 100])\n          // 设置子项的背景颜色为colors数组中对应索引的值\n          .backgroundColor(this.colors[item % 5])\n        }, (item: string) => item) // 设置key值为item\n      }\n      // 设置WaterFlow的列模板为自动填充，每列宽度为80\n      .columnsTemplate('repeat(auto-fill,80)')\n      // 设置列之间的间距为10\n      .columnsGap(10)\n      // 设置行之间的间距为5\n      .rowsGap(5)\n      // 设置内边距，左边距为5\n      .padding({left:5})\n      // 设置背景颜色为0xFAEEE0\n      .backgroundColor(0xFAEEE0)\n      // 设置宽度为100%\n      .width('100%')\n      // 设置高度为100%\n      .height('100%')\n    }\n  }\n}


/*\n实现一个支持双指缩放改变列数的瀑布流布局组件。组件包含一个可复用的瀑布流项组件，通过双指缩放手势动态调整瀑布流的列数，并保存当前列数状态。\n*/\n\n// 导入自定义的瀑布流数据源\nimport { WaterFlowDataSource } from './WaterFlowDataSource'\n\n// 定义可复用的瀑布流项组件\n@Reusable\n@Component\nstruct ReusableFlowItem {\n  @State item: number = 0 // 定义状态变量，用于存储当前项的编号\n\n  // 组件复用时调用的方法，用于更新组件状态\n  aboutToReuse(params: Record<string, number>) {\n    this.item = params.item; // 更新当前项的编号\n    console.info('Reuse item:' + this.item) // 打印日志，记录复用项的编号\n  }\n\n  // 组件首次出现时调用的方法\n  aboutToAppear() {\n    console.info('item:' + this.item) // 打印日志，记录当前项的编号\n  }\n\n  // 构建组件UI\n  build() {\n    Column() {\n      Text("N" + this.item).fontSize(12).height('16') // 显示当前项的编号\n      Image('res/waterFlow (' + this.item % 5 + ').JPG') // 显示当前项对应的图片\n        .objectFit(ImageFit.Fill) // 图片填充方式\n        .width('100%') // 图片宽度\n        .layoutWeight(1) // 布局权重\n    }\n  }\n}\n\n// 定义入口组件，实现瀑布流布局\n@Entry\n@Component\nstruct WaterFlowDemo {\n  minSize: number = 80 // 最小尺寸\n  maxSize: number = 180 // 最大尺寸\n  colors: number[] = [0xFFC0CB, 0xDA70D6, 0x6B8E23, 0x6A5ACD, 0x00FFFF, 0x00FF7F] // 颜色数组\n  @State columns: number = 2 // 定义状态变量，用于存储当前列数\n  dataSource: WaterFlowDataSource = new WaterFlowDataSource() // 数据源实例\n  private itemWidthArray: number[] = [] // 存储每个项的宽度\n  private itemHeightArray: number[] = [] // 存储每个项的高度\n\n  // 获取随机尺寸\n  getSize() {\n    let ret = Math.floor(Math.random() * this.maxSize) // 生成随机尺寸\n    return (ret > this.minSize ? ret : this.minSize) // 返回随机尺寸，确保不小于最小尺寸\n  }\n\n  // 设置项的尺寸数组\n  setItemSizeArray() {\n    for (let i = 0; i < 100; i++) {\n      this.itemWidthArray.push(this.getSize()) // 添加随机宽度\n      this.itemHeightArray.push(this.getSize()) // 添加随机高度\n    }\n  }\n\n  // 组件首次出现时调用的方法\n  aboutToAppear() {\n    let lastCount = AppStorage.get<number>('columnsCount') // 获取上一次保存的列数\n    if (typeof lastCount != 'undefined') {\n      this.columns = lastCount // 恢复上一次的列数\n    }\n    this.setItemSizeArray() // 初始化项的尺寸数组\n  }\n\n  // 构建组件UI\n  build() {\n    Column({ space: 2 }) {\n      Row() {\n        Text('双指缩放改变列数') // 提示文本\n          .height('5%') // 文本高度\n          .margin({ top: 10, left: 20 }) // 文本外边距\n      }\n\n      WaterFlow() {\n        LazyForEach(this.dataSource, (item: number) => { // 遍历数据源\n          FlowItem() {\n            ReusableFlowItem({ item: item }) // 创建可复用的瀑布流项\n          }\n          .width('100%') // 项的宽度\n          .height(this.itemHeightArray[item % 100]) // 项的高度\n          .backgroundColor(this.colors[item % 5]) // 项的背景颜色\n        }, (item: string) => item) // 唯一标识符\n      }\n      .columnsTemplate('1fr '.repeat(this.columns)) // 列模板\n      .columnsGap(10) // 列间距\n      .rowsGap(5) // 行间距\n      .backgroundColor(0xFAEEE0) // 背景颜色\n      .width('100%') // 宽度\n      .height('100%') // 高度\n      .layoutWeight(1) // 布局权重\n\n      .animation({ // 动画配置\n        duration: 300, // 动画时长\n        curve: Curve.Smooth // 动画曲线\n      })\n      .priorityGesture( // 优先手势\n        PinchGesture() // 双指缩放手势\n          .onActionEnd((event: GestureEvent) => { // 手势结束时的回调\n            console.info('end scale:' + event.scale) // 打印缩放比例\n\n            if (event.scale > 2) { // 缩放比例大于2时\n              this.columns-- // 减少列数\n            } else if (event.scale < 0.6) { // 缩放比例小于0.6时\n              this.columns++ // 增加列数\n            }\n\n            this.columns = Math.min(4, Math.max(1, this.columns)); // 限制列数范围\n            AppStorage.setOrCreate<number>('columnsCount', this.columns) // 保存当前列数\n          })\n      )\n    }\n  }\n}


/*\n实现一个瀑布流布局组件，支持动态加载数据、滚动事件监听、以及数据源的管理。组件包含一个WaterFlow布局，内部使用LazyForEach组件动态加载数据项，并根据数据源的变化动态调整布局。\n*/\n\n// 定义一个数据源类，实现IDataSource接口，用于管理数据和通知数据变化\nexport class WaterFlowDataSource implements IDataSource {\n  private dataArray: number[] = [] // 存储数据的数组\n  private listeners: DataChangeListener[] = [] // 存储数据变化监听器的数组\n\n  // 构造函数，初始化数据数组，填充100个数据项\n  constructor() {\n    for (let i = 0; i < 100; i++) {\n      this.dataArray.push(i)\n    }\n  }\n\n  // 获取指定索引的数据项\n  public getData(index: number): number {\n    return this.dataArray[index]\n  }\n\n  // 通知所有监听器数据已重新加载\n  notifyDataReload(): void {\n    this.listeners.forEach(listener => {\n      listener.onDataReloaded()\n    })\n  }\n\n  // 通知所有监听器在指定索引处添加了数据\n  notifyDataAdd(index: number): void {\n    this.listeners.forEach(listener => {\n      listener.onDataAdd(index)\n    })\n  }\n\n  // 通知所有监听器在指定索引处的数据已更改\n  notifyDataChange(index: number): void {\n    this.listeners.forEach(listener => {\n      listener.onDataChange(index)\n    })\n  }\n\n  // 通知所有监听器在指定索引处的数据已删除\n  notifyDataDelete(index: number): void {\n    this.listeners.forEach(listener => {\n      listener.onDataDelete(index)\n    })\n  }\n\n  // 通知所有监听器数据已移动\n  notifyDataMove(from: number, to: number): void {\n    this.listeners.forEach(listener => {\n      listener.onDataMove(from, to)\n    })\n  }\n\n  // 通知所有监听器数据集已更改\n  notifyDatasetChange(operations: DataOperation[]): void {\n    this.listeners.forEach(listener => {\n      listener.onDatasetChange(operations);\n    })\n  }\n\n  // 获取数据总数\n  public totalCount(): number {\n    return this.dataArray.length\n  }\n\n  // 注册数据变化监听器\n  registerDataChangeListener(listener: DataChangeListener): void {\n    if (this.listeners.indexOf(listener) < 0) {\n      this.listeners.push(listener)\n    }\n  }\n\n  // 注销数据变化监听器\n  unregisterDataChangeListener(listener: DataChangeListener): void {\n    const pos = this.listeners.indexOf(listener)\n    if (pos >= 0) {\n      this.listeners.splice(pos, 1)\n    }\n  }\n\n  // 在数据数组的开头添加一个数据项\n  public add1stItem(): void {\n    this.dataArray.splice(0, 0, this.dataArray.length)\n    this.notifyDataAdd(0)\n  }\n\n  // 在数据数组的末尾添加一个数据项\n  public addLastItem(): void {\n    this.dataArray.splice(this.dataArray.length, 0, this.dataArray.length)\n    this.notifyDataAdd(this.dataArray.length - 1)\n  }\n\n  // 在指定索引处添加一个数据项\n  public addItem(index: number): void {\n    this.dataArray.splice(index, 0, this.dataArray.length)\n    this.notifyDataAdd(index)\n  }\n\n  // 删除数据数组的第一个数据项\n  public delete1stItem(): void {\n    this.dataArray.splice(0, 1)\n    this.notifyDataDelete(0)\n  }\n\n  // 删除数据数组的第二个数据项\n  public delete2ndItem(): void {\n    this.dataArray.splice(1, 1)\n    this.notifyDataDelete(1)\n  }\n\n  // 删除数据数组的最后一个数据项\n  public deleteLastItem(): void {\n    this.dataArray.splice(-1, 1)\n    this.notifyDataDelete(this.dataArray.length)\n  }\n\n  // 删除指定索引处的数据项\n  public deleteItem(index: number): void {\n    this.dataArray.splice(index, 1)\n    this.notifyDataDelete(index)\n  }\n\n  // 重新加载数据，删除指定索引处的数据项\n  public reload(): void {\n    this.dataArray.splice(1, 1)\n    this.dataArray.splice(3, 2)\n    this.notifyDataReload()\n  }\n}\n\n// 导入自定义的数据源类\nimport { WaterFlowDataSource } from './WaterFlowDataSource'\n\n// 定义一个组件，用于展示瀑布流布局\n@Entry\n@Component\nstruct WaterFlowDemo {\n  @State minSize: number = 80 // 最小尺寸\n  @State maxSize: number = 180 // 最大尺寸\n  @State fontSize: number = 24 // 字体大小\n  @State colors: number[] = [0xFFC0CB, 0xDA70D6, 0x6B8E23, 0x6A5ACD, 0x00FFFF, 0x00FF7F] // 颜色数组\n  scroller: Scroller = new Scroller() // 滚动控制器\n  dataSource: WaterFlowDataSource = new WaterFlowDataSource() // 数据源实例\n  private itemWidthArray: number[] = [] // 存储每个项的宽度\n  private itemHeightArray: number[] = [] // 存储每个项的高度\n\n  // 获取随机尺寸\n  getSize() {\n    let ret = Math.floor(Math.random() * this.maxSize)\n    return (ret > this.minSize ? ret : this.minSize)\n  }\n\n  // 设置每个项的尺寸数组\n  setItemSizeArray() {\n    for (let i = 0; i < 100; i++) {\n      this.itemWidthArray.push(this.getSize())\n      this.itemHeightArray.push(this.getSize())\n    }\n  }\n\n  // 组件即将显示时调用，设置项的尺寸数组\n  aboutToAppear() {\n    this.setItemSizeArray()\n  }\n\n  // 定义一个Builder，用于生成每个项的底部内容\n  @Builder\n  itemFoot() {\n    Column() {\n      Text(`Footer`)\n        .fontSize(10)\n        .backgroundColor(Color.Red)\n        .width(50)\n        .height(50)\n        .align(Alignment.Center)\n        .margin({ top: 2 })\n    }\n  }\n\n  // 构建组件的UI\n  build() {\n    Column({ space: 2 }) {\n      WaterFlow() {\n        LazyForEach(this.dataSource, (item: number) => {\n          FlowItem() {\n            Column() {\n              Text("N" + item).fontSize(12).height('16')\n\n              Image('res/waterFlowTest(' + item % 5 + ').jpg')\n                .objectFit(ImageFit.Fill)\n                .width('100%')\n                .layoutWeight(1)\n            }\n          }\n          .onAppear(() => {\n            if (item + 20 == this.dataSource.totalCount()) {\n              for (let i = 0; i < 100; i++) {\n                this.dataSource.addLastItem()\n              }\n            }\n          })\n          .width('100%')\n          .height(this.itemHeightArray[item % 100])\n          .backgroundColor(this.colors[item % 5])\n        }, (item: string) => item)\n      }\n      .columnsTemplate("1fr 1fr") // 设置列模板\n      .columnsGap(10) // 设置列间距\n      .rowsGap(5) // 设置行间距\n      .backgroundColor(0xFAEEE0) // 设置背景颜色\n      .width('100%') // 设置宽度\n      .height('100%') // 设置高度\n      .onReachStart(() => {\n        console.info('waterFlow reach start')\n      })\n      .onScrollStart(() => {\n        console.info('waterFlow scroll start')\n      })\n      .onScrollStop(() => {\n        console.info('waterFlow scroll stop')\n      })\n      .onScrollFrameBegin((offset: number, state: ScrollState) => {\n        console.info('waterFlow scrollFrameBegin offset: ' + offset + ' state: ' + state.toString())\n        return { offsetRemain: offset }\n      })\n    }\n  }\n}


/*\n实现一个瀑布流布局组件，支持动态添加、删除和更新节（Section），并且支持滚动加载更多数据。\n*/\n\n// 导入自定义的WaterFlowDataSource类\nimport { WaterFlowDataSource } from './WaterFlowDataSource'\n\n// 定义一个可复用的组件ReusableFlowItem，用于显示瀑布流中的每个项目\n@Reusable\n@Component\nstruct ReusableFlowItem {\n  @State item: number = 0 // 定义一个状态变量item，用于存储当前项目的索引\n\n  // 当组件被复用时调用，更新item的值\n  aboutToReuse(params: Record<string, number>) {\n    this.item = params.item;\n    console.info('Reuse item:' + this.item)\n  }\n\n  // 当组件首次出现时调用，打印新项目的索引\n  aboutToAppear() {\n    console.info('new item:' + this.item)\n  }\n\n  // 构建组件的UI结构\n  build() {\n    Image('res/waterFlowTest(' + this.item % 5 + ').jpg') // 根据item的值加载不同的图片\n      .overlay('N' + this.item, { align: Alignment.Top }) // 在图片顶部显示项目的索引\n      .objectFit(ImageFit.Fill) // 设置图片的填充方式\n      .width('100%') // 设置图片的宽度为100%\n      .layoutWeight(1) // 设置布局权重为1\n  }\n}\n\n// 定义一个入口组件WaterFlowDemo，用于展示瀑布流布局\n@Entry\n@Component\nstruct WaterFlowDemo {\n  minSize: number = 80 // 定义项目高度的最小值\n  maxSize: number = 180 // 定义项目高度的最大值\n  fontSize: number = 24 // 定义字体大小\n  colors: number[] = [0xFFC0CB, 0xDA70D6, 0x6B8E23, 0x6A5ACD, 0x00FFFF, 0x00FF7F] // 定义颜色数组\n  scroller: Scroller = new Scroller() // 创建一个滚动控制器\n  dataSource: WaterFlowDataSource = new WaterFlowDataSource() // 创建一个数据源实例\n  dataCount: number = this.dataSource.totalCount() // 获取数据源的总项目数\n  private itemHeightArray: number[] = [] // 定义一个数组，用于存储每个项目的高度\n  @State sections: WaterFlowSections = new WaterFlowSections() // 定义一个状态变量sections，用于存储瀑布流的节\n  sectionMargin: Margin = { top: 10, left: 5, bottom: 10, right: 5 } // 定义节的边距\n\n  // 定义一个单列节的配置\n  oneColumnSection: SectionOptions = {\n    itemsCount: 4, // 节中的项目数\n    crossCount: 1, // 节中的列数\n    columnsGap: '5vp', // 列之间的间距\n    rowsGap: 10, // 行之间的间距\n    margin: this.sectionMargin, // 节的边距\n    onGetItemMainSizeByIndex: (index: number) => { // 根据索引获取项目的主尺寸（高度）\n      return this.itemHeightArray[index % 100]\n    }\n  }\n\n  // 定义一个双列节的配置\n  twoColumnSection: SectionOptions = {\n    itemsCount: 2, // 节中的项目数\n    crossCount: 2, // 节中的列数\n    onGetItemMainSizeByIndex: (index: number) => { // 根据索引获取项目的主尺寸（高度）\n      return 100\n    }\n  }\n\n  // 定义最后一个节的配置\n  lastSection: SectionOptions = {\n    itemsCount: 20, // 节中的项目数\n    crossCount: 2, // 节中的列数\n    onGetItemMainSizeByIndex: (index: number) => { // 根据索引获取项目的主尺寸（高度）\n      return this.itemHeightArray[index % 100]\n    }\n  }\n\n  // 获取随机尺寸的方法\n  getSize() {\n    let ret = Math.floor(Math.random() * this.maxSize)\n    return (ret > this.minSize ? ret : this.minSize)\n  }\n\n  // 设置项目高度数组的方法\n  setItemSizeArray() {\n    for (let i = 0; i < 100; i++) {\n      this.itemHeightArray.push(this.getSize())\n    }\n  }\n\n  // 当组件首次出现时调用，初始化项目高度数组并设置节的配置\n  aboutToAppear() {\n    this.setItemSizeArray()\n\n    let sectionOptions: SectionOptions[] = []\n    let count = 0\n    let oneOrTwo = 0\n    while (count < this.dataCount) {\n      if (this.dataCount - count < 20) {\n        this.lastSection.itemsCount = this.dataCount - count\n        sectionOptions.push(this.lastSection)\n        break;\n      }\n      if (oneOrTwo++ % 2 == 0) {\n        sectionOptions.push(this.oneColumnSection)\n        count += this.oneColumnSection.itemsCount\n      } else {\n        sectionOptions.push(this.twoColumnSection)\n        count += this.twoColumnSection.itemsCount\n      }\n    }\n    this.sections.splice(0, 0, sectionOptions)\n  }\n\n  // 构建组件的UI结构\n  build() {\n    Column({ space: 2 }) {\n      Row() {\n        Button('splice')\n          .height('5%')\n          .onClick(() => {\n            let totalCount: number = this.dataSource.totalCount()\n            let newSection: SectionOptions = {\n              itemsCount: totalCount,\n              crossCount: 2,\n              onGetItemMainSizeByIndex: (index: number) => {\n                return this.itemHeightArray[index % 100]\n              }\n            }\n            let oldLength: number = this.sections.length()\n            this.sections.splice(0, oldLength, [newSection])\n          })\n          .margin({ top: 10, left: 20 })\n        Button('update')\n          .height('5%')\n          .onClick(() => {\n            let newSection: SectionOptions = {\n              itemsCount: 6,\n              crossCount: 3,\n              columnsGap: 5,\n              rowsGap: 10,\n              margin: this.sectionMargin,\n              onGetItemMainSizeByIndex: (index: number) => {\n                return this.itemHeightArray[index % 100]\n              }\n            }\n            this.dataSource.addItem(this.oneColumnSection.itemsCount)\n            this.dataSource.addItem(this.oneColumnSection.itemsCount + 1)\n            this.dataSource.addItem(this.oneColumnSection.itemsCount + 2)\n            this.dataSource.addItem(this.oneColumnSection.itemsCount + 3)\n            const result: boolean = this.sections.update(1, newSection)\n            console.info('update:' + result)\n          })\n          .margin({ top: 10, left: 20 })\n        Button('delete')\n          .height('5%')\n          .onClick(() => {\n            let newSection: SectionOptions = {\n              itemsCount: 2,\n              crossCount: 2,\n              columnsGap: 5,\n              rowsGap: 10,\n              margin: this.sectionMargin,\n              onGetItemMainSizeByIndex: (index: number) => {\n                return this.itemHeightArray[index % 100]\n              }\n            }\n            this.dataSource.deleteItem(this.oneColumnSection.itemsCount)\n            this.dataSource.deleteItem(this.oneColumnSection.itemsCount)\n            this.dataSource.deleteItem(this.oneColumnSection.itemsCount)\n            this.dataSource.deleteItem(this.oneColumnSection.itemsCount)\n            this.sections.update(1, newSection)\n          })\n          .margin({ top: 10, left: 20 })\n        Button('values')\n          .height('5%')\n          .onClick(() => {\n            const sections: Array<SectionOptions> = this.sections.values();\n            for (const value of sections) {\n              console.log(JSON.stringify(value));\n            }\n            console.info('count:' + this.sections.length())\n          })\n          .margin({ top: 10, left: 20 })\n      }.margin({ bottom: 20 })\n\n      WaterFlow({ scroller: this.scroller, sections: this.sections }) {\n        LazyForEach(this.dataSource, (item: number) => {\n          FlowItem() {\n            ReusableFlowItem({ item: item })\n          }\n          .width('100%')\n          .backgroundColor(this.colors[item % 5])\n        }, (item: string) => item)\n      }\n      .columnsTemplate('1fr 1fr') \n      .columnsGap(10)\n      .rowsGap(5)\n      .backgroundColor(0xFAEEE0)\n      .width('100%')\n      .height('100%')\n      .layoutWeight(1)\n      .onScrollIndex((first: number, last: number) => {\n        if (last + 20 >= this.dataSource.totalCount()) {\n          for (let i = 0; i < 100; i++) {\n            this.dataSource.addLastItem()\n          }\n          const sections: Array<SectionOptions> = this.sections.values();\n          let newSection: SectionOptions = sections[this.sections.length() - 1];\n          newSection.itemsCount += 100;\n          this.sections.update(-1, newSection);\n        }\n      })\n    }\n  }\n}