[
    {
        "description": "示例1：加载本地网页\n\n该组件通过 `AtomicServiceWeb` 组件实现了一个加载本地网页的功能。布局采用 `Column` 组件，宽度占据整个屏幕，高度根据内容自适应。`AtomicServiceWeb` 组件用于加载本地 HTML 文件，通过 `src` 属性指定本地文件路径，使用 `$rawfile` 方法引用资源文件。`controller` 属性用于控制网页的加载和交互，通过 `@State` 装饰器绑定到组件的状态中。\n\n组件的样式和外观简洁，没有额外的装饰。组件的功能主要是加载并显示本地网页内容，用户可以在应用中浏览本地网页。",
        "code": "import { AtomicServiceWeb, AtomicServiceWebController } from '@kit.ArkUI';\n\n@Entry\n@Component\nstruct WebComponent {\n  @State controller: AtomicServiceWebController = new AtomicServiceWebController();\n\n  build() {\n    Column() {\n      AtomicServiceWeb({ src: $rawfile(\"index.html\"), controller: this.controller })\n    }\n  }\n}\n\n/*\n示例2：加载在线网页\n\n该组件通过 `AtomicServiceWeb` 组件实现了一个加载在线网页的功能。布局采用 `Column` 组件，宽度占据整个屏幕，高度根据内容自适应。`AtomicServiceWeb` 组件用于加载在线网页，通过 `src` 属性指定在线网页的 URL。`controller` 属性用于控制网页的加载和交互，通过 `@State` 装饰器绑定到组件的状态中。\n\n组件的样式和外观简洁，没有额外的装饰。组件的功能主要是加载并显示在线网页内容，用户可以在应用中浏览在线网页。\n*/\n\nimport { AtomicServiceWeb, AtomicServiceWebController } from '@kit.ArkUI';\n\n@Entry\n@Component\nstruct WebComponent {\n  @State controller: AtomicServiceWebController = new AtomicServiceWebController();\n\n  build() {\n    Column() {\n      AtomicServiceWeb({ src: 'https://www.example.com', controller: this.controller })\n    }\n  }\n}\n\n/*\n示例3：NavDestination容器中加载网页\n\n该组件通过 `NavDestination` 组件和 `AtomicServiceWeb` 组件实现了一个在导航目的地中加载网页的功能。布局采用 `NavDestination` 组件，宽度占据整个屏幕，高度根据内容自适应。`AtomicServiceWeb` 组件用于加载本地 HTML 文件，通过 `src` 属性指定本地文件路径，使用 `$rawfile` 方法引用资源文件。`controller` 属性用于控制网页的加载和交互，通过 `@State` 装饰器绑定到组件的状态中。`navPathStack` 属性用于管理导航路径栈。\n\n组件的样式和外观简洁，没有额外的装饰。组件的功能主要是加载并显示本地网页内容，并在导航目的地中进行展示。用户可以在应用中浏览本地网页，并通过导航进行页面切换。\n*/\n\nimport { AtomicServiceWeb, AtomicServiceWebController } from '@kit.ArkUI';\n\n@Builder\nexport function WebComponentBuilder(name: string, param: Object) {\n  WebComponent()\n}\n\n@Component\nstruct WebComponent {\n  navPathStack: NavPathStack = new NavPathStack();\n  @State controller: AtomicServiceWebController = new AtomicServiceWebController();\n\n  build() {\n    NavDestination() {\n      AtomicServiceWeb({ src: $rawfile(\"index.html\"), controller: this.controller, navPathStack: this.navPathStack })\n    }\n    .onReady((context: NavDestinationContext) => {\n      this.navPathStack = context.pathStack;\n    })\n  }\n}\n\n/*\n示例4：设置onMessage()事件回调\n\n该组件通过 `AtomicServiceWeb` 组件实现了一个加载本地网页并设置消息回调的功能。布局采用 `Column` 组件，宽度占据整个屏幕，高度根据内容自适应。`AtomicServiceWeb` 组件用于加载本地 HTML 文件，通过 `src` 属性指定本地文件路径，使用 `$rawfile` 方法引用资源文件。`controller` 属性用于控制网页的加载和交互，通过 `@State` 装饰器绑定到组件的状态中。`onMessage` 事件回调用于处理从网页发送的消息。\n\n组件的样式和外观简洁，没有额外的装饰。组件的功能主要是加载并显示本地网页内容，并在接收到网页发送的消息时触发回调函数，将消息内容打印到控制台。\n*/\n\nimport { AtomicServiceWeb, AtomicServiceWebController, OnMessageEvent } from '@kit.ArkUI';\n\n@Entry\n@Component\nstruct WebComponent {\n  @State controller: AtomicServiceWebController = new AtomicServiceWebController();\n\n  build() {\n    Column() {\n      AtomicServiceWeb({\n        src: $rawfile(\"index.html\"),\n        controller: this.controller,\n        onMessage: (event: OnMessageEvent) => {\n          console.log(`[AtomicServiceWebLog] onMessage data=${JSON.stringify(event.data)}`);\n        }\n      })\n    }\n  }\n}\n\n/*\n示例5：设置网页加载事件回调\n\n该组件通过 `AtomicServiceWeb` 组件实现了一个加载本地网页并设置多个加载事件回调的功能。布局采用 `Column` 组件，宽度占据整个屏幕，高度根据内容自适应。`AtomicServiceWeb` 组件用于加载本地 HTML 文件，通过 `src` 属性指定本地文件路径，使用 `$rawfile` 方法引用资源文件。`controller` 属性用于控制网页的加载和交互，通过 `@State` 装饰器绑定到组件的状态中。`onErrorReceive`、`onHttpErrorReceive`、`onPageBegin` 和 `onPageEnd` 事件回调用于处理网页加载过程中的各种事件。\n\n组件的样式和外观简洁，没有额外的装饰。组件的功能主要是加载并显示本地网页内容，并在网页加载过程中触发相应的事件回调，将事件信息打印到控制台。\n*/\n\nimport {\n  AtomicServiceWeb,\n  AtomicServiceWebController,\n  OnErrorReceiveEvent,\n  OnHttpErrorReceiveEvent,\n  OnPageBeginEvent,\n  OnPageEndEvent\n} from '@kit.ArkUI';\n\n@Entry\n@Component\nstruct WebComponent {\n  @State controller: AtomicServiceWebController = new AtomicServiceWebController();\n\n  build() {\n    Column() {\n      AtomicServiceWeb({\n        src: $rawfile('index.html'),\n        controller: this.controller,\n        onErrorReceive: (event: OnErrorReceiveEvent) => {\n          console.log(`AtomicServiceWebLog onErrorReceive event=${JSON.stringify({\n            requestUrl: event.request?.getRequestUrl(),\n            requestMethod: event.request?.getRequestMethod(),\n            errorCode: event.error?.getErrorCode(),\n            errorInfo: event.error?.getErrorInfo()\n          })}`);\n        },\n        onHttpErrorReceive: (event: OnHttpErrorReceiveEvent) => {\n          console.log(`AtomicServiceWebLog onHttpErrorReceive event=${JSON.stringify({\n            requestUrl: event.request?.getRequestUrl(),\n            requestMethod: event.request?.getRequestMethod(),\n            responseCode: event.response?.getResponseCode(),\n            responseData: event.response?.getResponseData(),\n          })}`);\n        },\n        onPageBegin: (event: OnPageBeginEvent) => {\n          console.log(`AtomicServiceWebLog onPageBegin event=${JSON.stringify({\n            url: event.url\n          })}`);\n        },\n        onPageEnd: (event: OnPageEndEvent) => {\n          console.log(`AtomicServiceWebLog onPageEnd event=${JSON.stringify({\n            url: event.url\n          })}`);\n        }\n      })\n    }\n  }\n}\n\n/*\n示例6：AtomicServiceWeb跟AtomicServiceWebController的使用示例\n\n该组件通过 `AtomicServiceWeb` 组件和 `AtomicServiceWebController` 实现了一个复杂的网页加载和控制功能。布局采用 `Column` 组件，宽度占据整个屏幕，高度根据内容自适应。`AtomicServiceWeb` 组件用于加载在线网页，通过 `src` 属性指定在线网页的 URL。`controller` 属性用于控制网页的加载和交互，通过 `@State` 装饰器绑定到组件的状态中。`onControllerAttached`、`onLoadIntercept`、`onProgressChange`、`onMessage`、`onPageBegin`、`onPageEnd`、`onHttpErrorReceive` 和 `onErrorReceive` 事件回调用于处理网页加载过程中的各种事件。\n\n组件的样式和外观简洁，没有额外的装饰。组件的功能主要是加载并显示在线网页内容，并在网页加载过程中触发相应的事件回调，将事件信息打印到控制台。此外，组件还提供了多个按钮，用于控制网页的前进、后退、刷新、加载新 URL 等操作。\n*/\n\nimport {\n  AtomicServiceWeb,\n  AtomicServiceWebController,\n  OnErrorReceiveEvent,\n  OnHttpErrorReceiveEvent,\n  OnPageBeginEvent,\n  OnPageEndEvent,\n  OnMessageEvent,\n  OnLoadInterceptEvent,\n  OnProgressChangeEvent\n} from '@kit.ArkUI';\n\n@Entry\n@Component\nstruct WebComponent {\n  @State darkMode: WebDarkMode = WebDarkMode.On;\n  @State forceDarkAccess: boolean = true;\n  @State mixedMode: MixedMode = MixedMode.None;\n  @State controller: AtomicServiceWebController = new AtomicServiceWebController();\n  @State num: number = 1;\n\n  build() {\n    Column() {\n      Button('accessForward').onClick(() => {\n        console.log(`AtomicServiceWebLog accessForward = ${this.controller.accessForward()}`);\n      })\n      Button('accessBackward').onClick(() => {\n        console.log(`AtomicServiceWebLog accessBackward = ${this.controller.accessBackward()}`);\n      })\n      Button('accessStep').onClick(() => {\n        console.log(`AtomicServiceWebLog accessStep = ${this.controller.accessStep(1)}`);\n      })\n      Button('forward').onClick(() => {\n        console.log(`AtomicServiceWebLog forward = ${this.controller.forward()}`);\n      })\n      Button('backward').onClick(() => {\n        console.log(`AtomicServiceWebLog backward = ${this.controller.backward()}`);\n      })\n      Button('refresh').onClick(() => {\n        console.log(`AtomicServiceWebLog refresh = ${this.controller.refresh()}`);\n      })\n      Button('loadUrl').onClick(() => {\n        console.log(`AtomicServiceWebLog loadUrl = ${this.controller.loadUrl('https://www.baidu.com/')}`);\n      })\n      Button('深色模式').onClick(() => {\n        this.forceDarkAccess = !this.forceDarkAccess;\n      })\n      Button('mixedMode').onClick(() => {\n        this.mixedMode = this.mixedMode == MixedMode.None ? MixedMode.All : MixedMode.None;\n      })\n      Button('点击').onClick(() => {\n        console.log(`AtomicServiceWebLog getUserAgent = ${this.controller.getUserAgent()}`);\n        console.log(`AtomicServiceWebLog getCustomUserAgent = ${this.controller.getCustomUserAgent()}`);\n        this.controller.setCustomUserAgent('test' + this.num++);\n        console.log(`AtomicServiceWebLog getUserAgent after set = ${this.controller.getUserAgent()}`);\n        console.log(`AtomicServiceWebLog getCustomUserAgent after set = ${this.controller.getCustomUserAgent()}`);\n      })\n      AtomicServiceWeb({\n        src: 'https://www.example.com',\n        mixedMode: this.mixedMode,\n        darkMode: this.darkMode,\n        forceDarkAccess: this.forceDarkAccess,\n        controller: this.controller,\n        onControllerAttached: () => {\n          console.log(\"AtomicServiceWebLog onControllerAttached call back success\");\n        },\n        onLoadIntercept: (event: OnLoadInterceptEvent) => {\n          console.log(\"AtomicServiceWebLog onLoadIntercept call back success \" + JSON.stringify({\n            getRequestUrl: event.data.getRequestUrl(),\n            getRequestMethod: event.data.getRequestMethod(),\n            getRequestHeader: event.data.getRequestHeader(),\n            isRequestGesture: event.data.isRequestGesture(),\n            isMainFrame: event.data.isMainFrame(),\n            isRedirect: event.data.isRedirect(),\n          }))\n          return false;\n        },\n        onProgressChange: (event: OnProgressChangeEvent) => {\n          console.log(\"AtomicServiceWebLog onProgressChange call back success \" + JSON.stringify(event));\n        },\n        onMessage: (event: OnMessageEvent) => {\n          console.log(\"onMessage call back success \" + JSON.stringify(event));\n        },\n        onPageBegin: (event: OnPageBeginEvent) => {\n          console.log(\"onPageBegin call back success \" + JSON.stringify(event));\n        },\n        onPageEnd: (event: OnPageEndEvent) => {\n          console.log(\"onPageEnd call back success \" + JSON.stringify(event));\n        },\n        onHttpErrorReceive: (event: OnHttpErrorReceiveEvent) => {\n          console.log(\"onHttpErrorReceive call back success \" + JSON.stringify(event));\n        },\n        onErrorReceive: (event: OnErrorReceiveEvent) => {\n          console.log(\"onErrorReceive call back success \" + JSON.stringify(event));\n        }\n      })\n    }\n  }\n}"
    }
]