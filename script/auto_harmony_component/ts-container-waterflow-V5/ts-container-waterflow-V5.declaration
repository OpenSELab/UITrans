{
    "description": "瀑布流容器，由“行”和“列”分割的单元格所组成，通过容器自身的排列规则，将不同大小的“项目”自上而下，如瀑布般紧密布局。",
    "details": null,
    "interfaces": [
        {
            "description": "WaterFlow(options?: WaterFlowOptions)",
            "params": {
                "options": {
                    "type": "WaterFlowOptions",
                    "required": false,
                    "description": "瀑布流选项。",
                    "default": null
                }
            }
        }
    ],
    "attributes": {
        "columnsTemplate": {
            "description": "设置当前瀑布流组件布局列的数量。",
            "params": {
                "value": {
                    "type": "string",
                    "required": true,
                    "description": "当前瀑布流组件布局列的数量。",
                    "default": "1fr"
                }
            }
        },
        "rowsTemplate": {
            "description": "设置当前瀑布流组件布局行的数量。",
            "params": {
                "value": {
                    "type": "string",
                    "required": true,
                    "description": "当前瀑布流组件布局行的数量。",
                    "default": "1fr"
                }
            }
        },
        "itemConstraintSize": {
            "description": "设置约束尺寸，子组件布局时，进行尺寸范围限制。",
            "params": {
                "value": {
                    "type": "ConstraintSizeOptions",
                    "required": true,
                    "description": "约束尺寸。",
                    "default": null
                }
            }
        },
        "columnsGap": {
            "description": "设置列与列的间距。",
            "params": {
                "value": {
                    "type": "Length",
                    "required": true,
                    "description": "列与列的间距。",
                    "default": 0
                }
            }
        },
        "rowsGap": {
            "description": "设置行与行的间距。",
            "params": {
                "value": {
                    "type": "Length",
                    "required": true,
                    "description": "行与行的间距。",
                    "default": 0
                }
            }
        },
        "layoutDirection": {
            "description": "设置布局的主轴方向。",
            "params": {
                "value": {
                    "type": "FlexDirection",
                    "required": true,
                    "description": "布局的主轴方向。",
                    "default": "FlexDirection.Column"
                }
            }
        },
        "enableScrollInteraction": {
            "description": "设置是否支持滚动手势。",
            "params": {
                "value": {
                    "type": "boolean",
                    "required": true,
                    "description": "是否支持滚动手势。",
                    "default": true
                }
            }
        },
        "nestedScroll": {
            "description": "设置向前向后两个方向上的嵌套滚动模式，实现与父组件的滚动联动。",
            "params": {
                "value": {
                    "type": "NestedScrollOptions",
                    "required": true,
                    "description": "嵌套滚动模式。",
                    "default": null
                }
            }
        },
        "friction": {
            "description": "设置摩擦系数，手动划动滚动区域时生效，只对惯性滚动过程有影响。",
            "params": {
                "value": {
                    "type": "number",
                    "required": true,
                    "description": "摩擦系数。",
                    "default": 0.75
                }
            }
        },
        "cachedCount": {
            "description": "设置预加载的FlowItem的数量，只在LazyForEach中生效。",
            "params": {
                "value": {
                    "type": "number",
                    "required": true,
                    "description": "预加载的FlowItem的数量。",
                    "default": 1
                }
            }
        }
    },
    "events": {
        "onReachStart": {
            "description": "瀑布流组件到达起始位置时触发。",
            "params": {},
            "returns": null
        },
        "onReachEnd": {
            "description": "瀑布流组件到底末尾位置时触发。",
            "params": {},
            "returns": null
        },
        "onScrollFrameBegin": {
            "description": "瀑布流开始滑动时触发，事件参数传入即将发生的滑动量，事件处理函数中可根据应用场景计算实际需要的滑动量并作为事件处理函数的返回值返回，瀑布流将按照返回值的实际滑动量进行滑动。",
            "params": {
                "offset": {
                    "type": "number",
                    "required": true,
                    "description": "即将发生的滑动量，单位vp。",
                    "default": null
                },
                "state": {
                    "type": "ScrollState",
                    "required": true,
                    "description": "当前滑动状态。",
                    "default": null
                }
            },
            "returns": {
                "offsetRemain": {
                    "type": "number",
                    "description": "实际滑动量，单位vp。"
                }
            }
        },
        "onScrollIndex": {
            "description": "当前瀑布流显示的起始位置/终止位置的子组件发生变化时触发。",
            "params": {
                "first": {
                    "type": "number",
                    "required": true,
                    "description": "当前显示的瀑布流起始位置的索引值。",
                    "default": null
                },
                "last": {
                    "type": "number",
                    "required": true,
                    "description": "当前显示的瀑布流终止位置的索引值。",
                    "default": null
                }
            },
            "returns": null
        }
    },
    "rules": null,
    "examples": [
        "/*\\n实现思路：\\n本示例展示了如何使用WaterFlow组件实现一个瀑布流布局，并通过随机生成的大小和颜色来动态填充每个FlowItem。\\n总体功能与效果描述：\\n该组件展示了100个不同大小和颜色的FlowItem，每个FlowItem包含一个文本和一个图片，布局采用瀑布流形式，自动填充列。\\n*/\\n\\n// WaterFlowDemo.ets\\nimport { WaterFlowDataSource } from './WaterFlowDataSource'\\n\\n@Entry\\n@Component\\nstruct WaterFlowDemo {\\n  @State minSize: number = 80 // 定义FlowItem的最小尺寸\\n  @State maxSize: number = 180 // 定义FlowItem的最大尺寸\\n  @State colors: number[] = [0xFFC0CB, 0xDA70D6, 0x6B8E23, 0x6A5ACD, 0x00FFFF, 0x00FF7F] // 定义FlowItem的背景颜色数组\\n  dataSource: WaterFlowDataSource = new WaterFlowDataSource() // 数据源实例\\n  private itemWidthArray: number[] = [] // 存储FlowItem宽度的数组\\n  private itemHeightArray: number[] = [] // 存储FlowItem高度的数组\\n\\n  // 获取随机尺寸\\n  getSize() {\\n    let ret = Math.floor(Math.random() * this.maxSize)\\n    return (ret > this.minSize ? ret : this.minSize) // 确保尺寸在最小和最大之间\\n  }\\n\\n  // 设置FlowItem的尺寸数组\\n  setItemSizeArray() {\\n    for (let i = 0; i < 100; i++) {\\n      this.itemWidthArray.push(this.getSize())\\n      this.itemHeightArray.push(this.getSize())\\n    }\\n  }\\n\\n  // 组件即将显示时调用，初始化尺寸数组\\n  aboutToAppear() {\\n    this.setItemSizeArray()\\n  }\\n\\n  build() {\\n    Column({ space: 2 }) {\\n      WaterFlow() {\\n        LazyForEach(this.dataSource, (item: number) => {\\n          FlowItem() {\\n            Column() {\\n              Text(\"N\" + item).fontSize(12).height('16') // 显示FlowItem的序号\\n              Image('res/waterFlowTest(' + item % 5 + ').jpg') // 显示FlowItem的图片\\n            }\\n          }\\n          .width('100%')\\n          .height(this.itemHeightArray[item % 100]) // 设置FlowItem的高度\\n          .backgroundColor(this.colors[item % 5]) // 设置FlowItem的背景颜色\\n        }, (item: string) => item)\\n      }\\n      .columnsTemplate('repeat(auto-fill,80)') // 设置列模板，自动填充列\\n      .columnsGap(10) // 设置列间距\\n      .rowsGap(5) // 设置行间距\\n      .padding({left:5}) // 设置左边距\\n      .backgroundColor(0xFAEEE0) // 设置背景颜色\\n      .width('100%') // 设置宽度\\n      .height('100%') // 设置高度\\n    }\\n  }\\n}",
        "/*\\n实现思路：\\n1. 创建一个可复用的组件 `ReusableFlowItem`，用于显示每个水流项的内容。\\n2. 创建一个主组件 `WaterFlowDemo`，用于管理水流布局和双指缩放功能。\\n3. 使用 `WaterFlow` 组件和 `LazyForEach` 循环生成水流项。\\n4. 通过双指缩放手势调整水流布局的列数。\\n\\n总体功能与效果描述：\\n- 显示一个水流布局，每个项包含一个文本和一个图片。\\n- 通过双指缩放手势动态调整水流布局的列数。\\n*/\\n\\n// ReusableFlowItem.ets\\n@Reusable\\n@Component\\nstruct ReusableFlowItem {\\n  @State item: number = 0\\n\\n  // 组件复用时调用，更新项的内容\\n  aboutToReuse(params: Record<string, number>) {\\n    this.item = params.item;\\n    console.info('Reuse item:' + this.item)\\n  }\\n\\n  // 组件首次出现时调用，输出项的内容\\n  aboutToAppear() {\\n    console.info('item:' + this.item)\\n  }\\n\\n  // 构建组件的UI\\n  build() {\\n    Column() {\\n      Text(\"N\" + this.item).fontSize(12).height('16')\\n      Image('res/waterFlow (' + this.item % 5 + ').JPG')\\n        .objectFit(ImageFit.Fill)\\n        .width('100%')\\n        .layoutWeight(1)\\n    }\\n  }\\n}\\n\\n// WaterFlowDemo.ets\\n@Entry\\n@Component\\nstruct WaterFlowDemo {\\n  minSize: number = 80\\n  maxSize: number = 180\\n  colors: number[] = [0xFFC0CB, 0xDA70D6, 0x6B8E23, 0x6A5ACD, 0x00FFFF, 0x00FF7F]\\n  @State columns: number = 2\\n  dataSource: WaterFlowDataSource = new WaterFlowDataSource()\\n  private itemWidthArray: number[] = []\\n  private itemHeightArray: number[] = []\\n\\n  // 获取随机大小\\n  getSize() {\\n    let ret = Math.floor(Math.random() * this.maxSize)\\n    return (ret > this.minSize ? ret : this.minSize)\\n  }\\n\\n  // 设置项的宽度和高度数组\\n  setItemSizeArray() {\\n    for (let i = 0; i < 100; i++) {\\n      this.itemWidthArray.push(this.getSize())\\n      this.itemHeightArray.push(this.getSize())\\n    }\\n  }\\n\\n  // 组件首次出现时调用，初始化列数和项的大小数组\\n  aboutToAppear() {\\n    let lastCount = AppStorage.get<number>('columnsCount')\\n    if (typeof lastCount != 'undefined') {\\n      this.columns = lastCount\\n    }\\n    this.setItemSizeArray()\\n  }\\n\\n  // 构建组件的UI\\n  build() {\\n    Column({ space: 2 }) {\\n      Row() {\\n        Text('双指缩放改变列数')\\n          .height('5%')\\n          .margin({ top: 10, left: 20 })\\n      }\\n\\n      WaterFlow() {\\n        LazyForEach(this.dataSource, (item: number) => {\\n          FlowItem() {\\n            ReusableFlowItem({ item: item })\\n          }\\n          .width('100%')\\n          .height(this.itemHeightArray[item % 100])\\n          .backgroundColor(this.colors[item % 5])\\n        }, (item: string) => item)\\n      }\\n      .columnsTemplate('1fr '.repeat(this.columns))\\n      .columnsGap(10)\\n      .rowsGap(5)\\n      .backgroundColor(0xFAEEE0)\\n      .width('100%')\\n      .height('100%')\\n      .layoutWeight(1)\\n\\n      .animation({\\n        duration: 300,\\n        curve: Curve.Smooth\\n      })\\n      .priorityGesture(\\n        PinchGesture()\\n          .onActionEnd((event: GestureEvent) => {\\n            console.info('end scale:' + event.scale)\\n\\n            if (event.scale > 2) {\\n              this.columns--\\n            } else if (event.scale < 0.6) {\\n              this.columns++\\n            }\\n\\n            this.columns = Math.min(4, Math.max(1, this.columns));\\n            AppStorage.setOrCreate<number>('columnsCount', this.columns)\\n          })\\n      )\\n    }\\n  }\\n}",
        "/*\\n实现思路：\\n1. 创建一个数据源类 `WaterFlowDataSource`，用于管理数据和通知数据变化。\\n2. 在 `WaterFlowDemo` 组件中使用 `WaterFlow` 组件展示数据，并实现动态加载和样式设置。\\n3. 使用 `LazyForEach` 循环渲染数据项，并在每个数据项中展示文本和图片。\\n4. 实现滚动事件监听和动态数据加载。\\n\\n总体功能与效果描述：\\n- 展示一个瀑布流布局，包含动态加载的数据项。\\n- 每个数据项包含文本和图片，并具有随机的大小和颜色。\\n- 支持滚动事件监听和动态数据加载。\\n*/\\n\\n// WaterFlowDataSource.ts\\nexport class WaterFlowDataSource implements IDataSource {\\n  private dataArray: number[] = []\\n  private listeners: DataChangeListener[] = []\\n\\n  constructor() {\\n    // 初始化数据数组，填充100个数字\\n    for (let i = 0; i < 100; i++) {\\n      this.dataArray.push(i)\\n    }\\n  }\\n\\n  // 获取指定索引的数据\\n  public getData(index: number): number {\\n    return this.dataArray[index]\\n  }\\n\\n  // 通知所有监听器数据重新加载\\n  notifyDataReload(): void {\\n    this.listeners.forEach(listener => {\\n      listener.onDataReloaded()\\n    })\\n  }\\n\\n  // 通知所有监听器数据添加\\n  notifyDataAdd(index: number): void {\\n    this.listeners.forEach(listener => {\\n      listener.onDataAdd(index)\\n    })\\n  }\\n\\n  // 通知所有监听器数据变化\\n  notifyDataChange(index: number): void {\\n    this.listeners.forEach(listener => {\\n      listener.onDataChange(index)\\n    })\\n  }\\n\\n  // 通知所有监听器数据删除\\n  notifyDataDelete(index: number): void {\\n    this.listeners.forEach(listener => {\\n      listener.onDataDelete(index)\\n    })\\n  }\\n\\n  // 通知所有监听器数据移动\\n  notifyDataMove(from: number, to: number): void {\\n    this.listeners.forEach(listener => {\\n      listener.onDataMove(from, to)\\n    })\\n  }\\n\\n  // 通知所有监听器数据集变化\\n  notifyDatasetChange(operations: DataOperation[]): void {\\n    this.listeners.forEach(listener => {\\n      listener.onDatasetChange(operations);\\n    })\\n  }\\n\\n  // 获取数据总数\\n  public totalCount(): number {\\n    return this.dataArray.length\\n  }\\n\\n  // 注册数据变化监听器\\n  registerDataChangeListener(listener: DataChangeListener): void {\\n    if (this.listeners.indexOf(listener) < 0) {\\n      this.listeners.push(listener)\\n    }\\n  }\\n\\n  // 注销数据变化监听器\\n  unregisterDataChangeListener(listener: DataChangeListener): void {\\n    const pos = this.listeners.indexOf(listener)\\n    if (pos >= 0) {\\n      this.listeners.splice(pos, 1)\\n    }\\n  }\\n\\n  // 在数据数组头部添加一个新项\\n  public add1stItem(): void {\\n    this.dataArray.splice(0, 0, this.dataArray.length)\\n    this.notifyDataAdd(0)\\n  }\\n\\n  // 在数据数组尾部添加一个新项\\n  public addLastItem(): void {\\n    this.dataArray.splice(this.dataArray.length, 0, this.dataArray.length)\\n    this.notifyDataAdd(this.dataArray.length - 1)\\n  }\\n\\n  // 在指定索引位置添加一个新项\\n  public addItem(index: number): void {\\n    this.dataArray.splice(index, 0, this.dataArray.length)\\n    this.notifyDataAdd(index)\\n  }\\n\\n  // 删除数据数组头部的一个项\\n  public delete1stItem(): void {\\n    this.dataArray.splice(0, 1)\\n    this.notifyDataDelete(0)\\n  }\\n\\n  // 删除数据数组第二个项\\n  public delete2ndItem(): void {\\n    this.dataArray.splice(1, 1)\\n    this.notifyDataDelete(1)\\n  }\\n\\n  // 删除数据数组尾部的一个项\\n  public deleteLastItem(): void {\\n    this.dataArray.splice(-1, 1)\\n    this.notifyDataDelete(this.dataArray.length)\\n  }\\n\\n  // 删除指定索引位置的一个项\\n  public deleteItem(index: number): void {\\n    this.dataArray.splice(index, 1)\\n    this.notifyDataDelete(index)\\n  }\\n\\n  // 重新加载数据\\n  public reload(): void {\\n    this.dataArray.splice(1, 1)\\n    this.dataArray.splice(3, 2)\\n    this.notifyDataReload()\\n  }\\n}\\n\\n// WaterFlowDemo.ets\\nimport { WaterFlowDataSource } from './WaterFlowDataSource'\\n\\n@Entry\\n@Component\\nstruct WaterFlowDemo {\\n  @State minSize: number = 80\\n  @State maxSize: number = 180\\n  @State fontSize: number = 24\\n  @State colors: number[] = [0xFFC0CB, 0xDA70D6, 0x6B8E23, 0x6A5ACD, 0x00FFFF, 0x00FF7F]\\n  scroller: Scroller = new Scroller()\\n  dataSource: WaterFlowDataSource = new WaterFlowDataSource()\\n  private itemWidthArray: number[] = []\\n  private itemHeightArray: number[] = []\\n\\n  // 获取随机大小\\n  getSize() {\\n    let ret = Math.floor(Math.random() * this.maxSize)\\n    return (ret > this.minSize ? ret : this.minSize)\\n  }\\n\\n  // 设置数据项的宽度和高度数组\\n  setItemSizeArray() {\\n    for (let i = 0; i < 100; i++) {\\n      this.itemWidthArray.push(this.getSize())\\n      this.itemHeightArray.push(this.getSize())\\n    }\\n  }\\n\\n  // 组件即将显示时调用，初始化数据项大小\\n  aboutToAppear() {\\n    this.setItemSizeArray()\\n  }\\n\\n  // 创建数据项的尾部组件\\n  @Builder\\n  itemFoot() {\\n    Column() {\\n      Text(`Footer`)\\n        .fontSize(10)\\n        .backgroundColor(Color.Red)\\n        .width(50)\\n        .height(50)\\n        .align(Alignment.Center)\\n        .margin({ top: 2 })\\n    }\\n  }\\n\\n  // 构建主界面\\n  build() {\\n    Column({ space: 2 }) {\\n      WaterFlow() {\\n        LazyForEach(this.dataSource, (item: number) => {\\n          FlowItem() {\\n            Column() {\\n              Text(\"N\" + item).fontSize(12).height('16')\\n\\n              Image('res/waterFlowTest(' + item % 5 + ').jpg')\\n                .objectFit(ImageFit.Fill)\\n                .width('100%')\\n                .layoutWeight(1)\\n            }\\n          }\\n          .onAppear(() => {\\n            // 当滚动到接近底部时，动态加载更多数据\\n            if (item + 20 == this.dataSource.totalCount()) {\\n              for (let i = 0; i < 100; i++) {\\n                this.dataSource.addLastItem()\\n              }\\n            }\\n          })\\n          .width('100%')\\n          .height(this.itemHeightArray[item % 100])\\n          .backgroundColor(this.colors[item % 5])\\n        }, (item: string) => item)\\n      }\\n      .columnsTemplate(\"1fr 1fr\")\\n      .columnsGap(10)\\n      .rowsGap(5)\\n      .backgroundColor(0xFAEEE0)\\n      .width('100%')\\n      .height('100%')\\n      .onReachStart(() => {\\n        console.info('waterFlow reach start')\\n      })\\n      .onScrollStart(() => {\\n        console.info('waterFlow scroll start')\\n      })\\n      .onScrollStop(() => {\\n        console.info('waterFlow scroll stop')\\n      })\\n      .onScrollFrameBegin((offset: number, state: ScrollState) => {\\n        console.info('waterFlow scrollFrameBegin offset: ' + offset + ' state: ' + state.toString())\\n        return { offsetRemain: offset }\\n      })\\n    }\\n  }\\n}",
        "/*\\n实现思路：\\n1. 创建一个可复用的组件 `ReusableFlowItem`，用于显示单个水流项。\\n2. 定义一个主组件 `WaterFlowDemo`，包含多个按钮用于操作水流布局的不同部分。\\n3. 使用 `WaterFlow` 组件来展示水流布局，并通过 `LazyForEach` 动态加载数据。\\n4. 实现按钮功能，包括添加、更新、删除和查看水流布局的各个部分。\\n5. 通过 `onScrollIndex` 事件处理滚动加载更多数据的功能。\\n\\n总体功能与效果描述：\\n该示例展示了如何使用 `WaterFlow` 组件来创建一个动态的水流布局，支持通过按钮进行布局的添加、更新、删除和查看操作，并实现滚动加载更多数据的功能。\\n*/\\n\\n// WaterFlowDemo.ets\\n\\nimport { WaterFlowDataSource } from './WaterFlowDataSource'\\n\\n@Reusable\\n@Component\\nstruct ReusableFlowItem {\\n  @State item: number = 0\\n\\n  // 当组件即将被复用时，更新组件的状态\\n  aboutToReuse(params: Record<string, number>) {\\n    this.item = params.item;\\n    console.info('Reuse item:' + this.item)\\n  }\\n\\n  // 当组件即将显示时，输出新项的信息\\n  aboutToAppear() {\\n    console.info('new item:' + this.item)\\n  }\\n\\n  // 构建组件的UI\\n  build() {\\n    Image('res/waterFlowTest(' + this.item % 5 + ').jpg')\\n      .overlay('N' + this.item, { align: Alignment.Top })\\n      .objectFit(ImageFit.Fill)\\n      .width('100%')\\n      .layoutWeight(1)\\n  }\\n}\\n\\n@Entry\\n@Component\\nstruct WaterFlowDemo {\\n  minSize: number = 80\\n  maxSize: number = 180\\n  fontSize: number = 24\\n  colors: number[] = [0xFFC0CB, 0xDA70D6, 0x6B8E23, 0x6A5ACD, 0x00FFFF, 0x00FF7F]\\n  scroller: Scroller = new Scroller()\\n  dataSource: WaterFlowDataSource = new WaterFlowDataSource()\\n  dataCount: number = this.dataSource.totalCount()\\n  private itemHeightArray: number[] = []\\n  @State sections: WaterFlowSections = new WaterFlowSections()\\n  sectionMargin: Margin = { top: 10, left: 5, bottom: 10, right: 5 }\\n  oneColumnSection: SectionOptions = {\\n    itemsCount: 4,\\n    crossCount: 1,\\n    columnsGap: '5vp',\\n    rowsGap: 10,\\n    margin: this.sectionMargin,\\n    onGetItemMainSizeByIndex: (index: number) => {\\n      return this.itemHeightArray[index % 100]\\n    }\\n  }\\n  twoColumnSection: SectionOptions = {\\n    itemsCount: 2,\\n    crossCount: 2,\\n    onGetItemMainSizeByIndex: (index: number) => {\\n      return 100\\n    }\\n  }\\n  lastSection: SectionOptions = {\\n    itemsCount: 20,\\n    crossCount: 2,\\n    onGetItemMainSizeByIndex: (index: number) => {\\n      return this.itemHeightArray[index % 100]\\n    }\\n  }\\n\\n  // 获取随机大小\\n  getSize() {\\n    let ret = Math.floor(Math.random() * this.maxSize)\\n    return (ret > this.minSize ? ret : this.minSize)\\n  }\\n\\n  // 设置项的大小数组\\n  setItemSizeArray() {\\n    for (let i = 0; i < 100; i++) {\\n      this.itemHeightArray.push(this.getSize())\\n    }\\n  }\\n\\n  // 当组件即将显示时，初始化数据\\n  aboutToAppear() {\\n    this.setItemSizeArray()\\n\\n    let sectionOptions: SectionOptions[] = []\\n    let count = 0\\n    let oneOrTwo = 0\\n    while (count < this.dataCount) {\\n      if (this.dataCount - count < 20) {\\n        this.lastSection.itemsCount = this.dataCount - count\\n        sectionOptions.push(this.lastSection)\\n        break;\\n      }\\n      if (oneOrTwo++ % 2 == 0) {\\n        sectionOptions.push(this.oneColumnSection)\\n        count += this.oneColumnSection.itemsCount\\n      } else {\\n        sectionOptions.push(this.twoColumnSection)\\n        count += this.twoColumnSection.itemsCount\\n      }\\n    }\\n    this.sections.splice(0, 0, sectionOptions)\\n  }\\n\\n  build() {\\n    Column({ space: 2 }) {\\n      Row() {\\n        Button('splice')\\n          .height('5%')\\n          .onClick(() => {\\n            let totalCount: number = this.dataSource.totalCount()\\n            let newSection: SectionOptions = {\\n              itemsCount: totalCount,\\n              crossCount: 2,\\n              onGetItemMainSizeByIndex: (index: number) => {\\n                return this.itemHeightArray[index % 100]\\n              }\\n            }\\n            let oldLength: number = this.sections.length()\\n            this.sections.splice(0, oldLength, [newSection])\\n          })\\n          .margin({ top: 10, left: 20 })\\n        Button('update')\\n          .height('5%')\\n          .onClick(() => {\\n            let newSection: SectionOptions = {\\n              itemsCount: 6,\\n              crossCount: 3,\\n              columnsGap: 5,\\n              rowsGap: 10,\\n              margin: this.sectionMargin,\\n              onGetItemMainSizeByIndex: (index: number) => {\\n                return this.itemHeightArray[index % 100]\\n              }\\n            }\\n            this.dataSource.addItem(this.oneColumnSection.itemsCount)\\n            this.dataSource.addItem(this.oneColumnSection.itemsCount + 1)\\n            this.dataSource.addItem(this.oneColumnSection.itemsCount + 2)\\n            this.dataSource.addItem(this.oneColumnSection.itemsCount + 3)\\n            const result: boolean = this.sections.update(1, newSection)\\n            console.info('update:' + result)\\n          })\\n          .margin({ top: 10, left: 20 })\\n        Button('delete')\\n          .height('5%')\\n          .onClick(() => {\\n            let newSection: SectionOptions = {\\n              itemsCount: 2,\\n              crossCount: 2,\\n              columnsGap: 5,\\n              rowsGap: 10,\\n              margin: this.sectionMargin,\\n              onGetItemMainSizeByIndex: (index: number) => {\\n                return this.itemHeightArray[index % 100]\\n              }\\n            }\\n            this.dataSource.deleteItem(this.oneColumnSection.itemsCount)\\n            this.dataSource.deleteItem(this.oneColumnSection.itemsCount)\\n            this.dataSource.deleteItem(this.oneColumnSection.itemsCount)\\n            this.dataSource.deleteItem(this.oneColumnSection.itemsCount)\\n            this.sections.update(1, newSection)\\n          })\\n          .margin({ top: 10, left: 20 })\\n        Button('values')\\n          .height('5%')\\n          .onClick(() => {\\n            const sections: Array<SectionOptions> = this.sections.values();\\n            for (const value of sections) {\\n              console.log(JSON.stringify(value));\\n            }\\n            console.info('count:' + this.sections.length())\\n          })\\n          .margin({ top: 10, left: 20 })\\n      }.margin({ bottom: 20 })\\n\\n      WaterFlow({ scroller: this.scroller, sections: this.sections }) {\\n        LazyForEach(this.dataSource, (item: number) => {\\n          FlowItem() {\\n            ReusableFlowItem({ item: item })\\n          }\\n          .width('100%')\\n          .backgroundColor(this.colors[item % 5])\\n        }, (item: string) => item)\\n      }\\n      .columnsTemplate('1fr 1fr')\\n      .columnsGap(10)\\n      .rowsGap(5)\\n      .backgroundColor(0xFAEEE0)\\n      .width('100%')\\n      .height('100%')\\n      .layoutWeight(1)\\n      .onScrollIndex((first: number, last: number) => {\\n        if (last + 20 >= this.dataSource.totalCount()) {\\n          for (let i = 0; i < 100; i++) {\\n            this.dataSource.addLastItem()\\n          }\\n          const sections: Array<SectionOptions> = this.sections.values();\\n          let newSection: SectionOptions = sections[this.sections.length() - 1];\\n          newSection.itemsCount += 100;\\n          this.sections.update(-1, newSection);\\n        }\\n      })\\n    }\\n  }\\n}"
    ],
    "is_common_attrs": true
}