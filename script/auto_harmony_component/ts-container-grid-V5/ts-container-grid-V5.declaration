{
    "description": "网格容器，由“行”和“列”分割的单元格所组成，通过指定“项目”所在的单元格做出各种各样的布局。",
    "details": "该组件从API Version 7开始支持。后续版本如有新增内容，则采用上角标单独标记该内容的起始版本。",
    "interfaces": [
        {
            "description": "Grid(scroller?: Scroller, layoutOptions?: GridLayoutOptions)",
            "params": {
                "scroller": {
                    "type": "Scroller",
                    "required": false,
                    "description": "可滚动组件的控制器。用于与可滚动组件进行绑定。",
                    "default": null
                },
                "layoutOptions": {
                    "type": "GridLayoutOptions",
                    "required": false,
                    "description": "布局选项。",
                    "default": null
                }
            }
        }
    ],
    "attributes": {
        "columnsTemplate": {
            "description": "设置当前网格布局列的数量、固定列宽或最小列宽值，不设置时默认1列。",
            "params": {
                "value": {
                    "type": "string",
                    "required": true,
                    "description": "当前网格布局列的数量或最小列宽值。",
                    "default": null
                }
            }
        },
        "rowsTemplate": {
            "description": "设置当前网格布局行的数量、固定行高或最小行高值，不设置时默认1行。",
            "params": {
                "value": {
                    "type": "string",
                    "required": true,
                    "description": "当前网格布局行的数量或最小行高值。",
                    "default": null
                }
            }
        },
        "columnsGap": {
            "description": "设置列与列的间距。设置为小于0的值时，按默认值显示。",
            "params": {
                "value": {
                    "type": "Length",
                    "required": true,
                    "description": "列与列的间距。",
                    "default": "0"
                }
            }
        },
        "rowsGap": {
            "description": "设置行与行的间距。设置为小于0的值时，按默认值显示。",
            "params": {
                "value": {
                    "type": "Length",
                    "required": true,
                    "description": "行与行的间距。",
                    "default": "0"
                }
            }
        },
        "scrollBar": {
            "description": "设置滚动条状态。",
            "params": {
                "value": {
                    "type": "BarState",
                    "required": true,
                    "description": "滚动条状态。",
                    "default": "BarState.Auto"
                }
            }
        },
        "scrollBarColor": {
            "description": "设置滚动条的颜色。",
            "params": {
                "value": {
                    "type": [
                        "Color",
                        "number",
                        "string"
                    ],
                    "required": true,
                    "description": "滚动条的颜色。",
                    "default": "'#182431'（40%不透明度）"
                }
            }
        },
        "scrollBarWidth": {
            "description": "设置滚动条的宽度，不支持百分比设置。宽度设置后，滚动条正常状态和按压状态宽度均为滚动条的宽度值。如果滚动条的宽度超过Grid组件主轴方向的高度，则滚动条的宽度会变为默认值。",
            "params": {
                "value": {
                    "type": [
                        "number",
                        "string"
                    ],
                    "required": true,
                    "description": "滚动条的宽度。",
                    "default": "4"
                }
            }
        },
        "cachedCount": {
            "description": "设置预加载的GridItem的数量，只在LazyForEach和开启了virtualScroll开关的Repeat中生效。设置为小于0的值时，按默认值显示。",
            "params": {
                "value": {
                    "type": "number",
                    "required": true,
                    "description": "预加载的GridItem的数量。",
                    "default": "1"
                }
            }
        },
        "editMode": {
            "description": "设置Grid是否进入编辑模式，进入编辑模式可以拖拽Grid组件内部GridItem。",
            "params": {
                "value": {
                    "type": "boolean",
                    "required": true,
                    "description": "Grid是否进入编辑模式。",
                    "default": "false"
                }
            }
        },
        "layoutDirection": {
            "description": "设置布局的主轴方向。",
            "params": {
                "value": {
                    "type": "GridDirection",
                    "required": true,
                    "description": "布局的主轴方向。",
                    "default": "GridDirection.Row"
                }
            }
        },
        "maxCount": {
            "description": "设置可显示的最大行数或列数。设置为小于1的值时，按默认值显示。",
            "params": {
                "value": {
                    "type": "number",
                    "required": true,
                    "description": "可显示的最大行数或列数。",
                    "default": "Infinity"
                }
            }
        },
        "minCount": {
            "description": "设置可显示的最小行数或列数。设置为小于1的值时，按默认值显示。",
            "params": {
                "value": {
                    "type": "number",
                    "required": true,
                    "description": "可显示的最小行数或列数。",
                    "default": "1"
                }
            }
        },
        "cellLength": {
            "description": "设置一行的高度或者一列的宽度。",
            "params": {
                "value": {
                    "type": "number",
                    "required": true,
                    "description": "一行的高度或者一列的宽度。",
                    "default": "第一个元素的大小"
                }
            }
        },
        "multiSelectable": {
            "description": "设置是否开启鼠标框选。开启框选后，可以配合Griditem的selected属性和onSelect事件获取GridItem的选中状态，还可以设置选中态样式（无默认选中样式）。",
            "params": {
                "value": {
                    "type": "boolean",
                    "required": true,
                    "description": "是否开启鼠标框选。",
                    "default": "false"
                }
            }
        },
        "supportAnimation": {
            "description": "设置是否支持动画。当前支持GridItem拖拽动画。仅在滚动模式下（只设置rowsTemplate、columnsTemplate其中一个）支持动画。",
            "params": {
                "value": {
                    "type": "boolean",
                    "required": true,
                    "description": "是否支持动画。",
                    "default": "false"
                }
            }
        },
        "edgeEffect": {
            "description": "设置边缘滑动效果。",
            "params": {
                "value": {
                    "type": "EdgeEffect",
                    "required": true,
                    "description": "Grid组件的边缘滑动效果，支持弹簧效果和阴影效果。",
                    "default": "EdgeEffect.None"
                },
                "options": {
                    "type": "EdgeEffectOptions",
                    "required": false,
                    "description": "组件内容大小小于组件自身时，是否开启滑动效果。设置为{ alwaysEnabled: true }会开启滑动效果，{ alwaysEnabled: false }不开启。",
                    "default": "{ alwaysEnabled: false }"
                }
            }
        },
        "enableScrollInteraction": {
            "description": "设置是否支持滚动手势，当设置为false时，无法通过手指或者鼠标滚动，但不影响控制器的滚动接口。",
            "params": {
                "value": {
                    "type": "boolean",
                    "required": true,
                    "description": "是否支持滚动手势。",
                    "default": "true"
                }
            }
        },
        "nestedScroll": {
            "description": "设置嵌套滚动选项。设置向前向后两个方向上的嵌套滚动模式，实现与父组件的滚动联动。",
            "params": {
                "value": {
                    "type": "NestedScrollOptions",
                    "required": true,
                    "description": "嵌套滚动选项。",
                    "default": null
                }
            }
        },
        "friction": {
            "description": "设置摩擦系数，手动划动滚动区域时生效，只对惯性滚动过程有影响，对惯性滚动过程中的链式效果有间接影响。设置为小于等于0的值时，按默认值处理。",
            "params": {
                "value": {
                    "type": [
                        "number",
                        "Resource"
                    ],
                    "required": true,
                    "description": "摩擦系数。",
                    "default": "非可穿戴设备为0.75，可穿戴设备为0.9。"
                }
            }
        }
    },
    "events": {
        "onScrollIndex": {
            "description": "当前网格显示的起始位置/终止位置的item发生变化时触发。网格初始化时会触发一次。Grid显示区域上第一个子组件/最后一个组件的索引值有变化就会触发。",
            "params": {
                "first": {
                    "type": "number",
                    "required": true,
                    "description": "当前显示的网格起始位置的索引值。",
                    "default": null
                },
                "last": {
                    "type": "number",
                    "required": true,
                    "description": "当前显示的网格终止位置的索引值。",
                    "default": null
                }
            },
            "returns": null
        },
        "onItemDragStart": {
            "description": "开始拖拽网格元素时触发。返回void表示不能拖拽。",
            "params": {
                "event": {
                    "type": "ItemDragInfo",
                    "required": true,
                    "description": "拖拽点的信息。",
                    "default": null
                },
                "itemIndex": {
                    "type": "number",
                    "required": true,
                    "description": "被拖拽网格元素索引值。",
                    "default": null
                }
            },
            "returns": null
        },
        "onItemDragEnter": {
            "description": "拖拽进入网格元素范围内时触发。",
            "params": {
                "event": {
                    "type": "ItemDragInfo",
                    "required": true,
                    "description": "拖拽点的信息。",
                    "default": null
                }
            },
            "returns": null
        },
        "onItemDragMove": {
            "description": "拖拽在网格元素范围内移动时触发。",
            "params": {
                "event": {
                    "type": "ItemDragInfo",
                    "required": true,
                    "description": "拖拽点的信息。",
                    "default": null
                },
                "itemIndex": {
                    "type": "number",
                    "required": true,
                    "description": "拖拽起始位置。",
                    "default": null
                },
                "insertIndex": {
                    "type": "number",
                    "required": true,
                    "description": "拖拽插入位置。",
                    "default": null
                }
            },
            "returns": null
        },
        "onItemDragLeave": {
            "description": "拖拽离开网格元素时触发。",
            "params": {
                "event": {
                    "type": "ItemDragInfo",
                    "required": true,
                    "description": "拖拽点的信息。",
                    "default": null
                },
                "itemIndex": {
                    "type": "number",
                    "required": true,
                    "description": "拖拽离开的网格元素索引值。",
                    "default": null
                }
            },
            "returns": null
        },
        "onItemDrop": {
            "description": "绑定该事件的网格元素可作为拖拽释放目标，当在网格元素内停止拖拽时触发。",
            "params": {
                "event": {
                    "type": "ItemDragInfo",
                    "required": true,
                    "description": "拖拽点的信息。",
                    "default": null
                },
                "itemIndex": {
                    "type": "number",
                    "required": true,
                    "description": "拖拽起始位置。",
                    "default": null
                },
                "insertIndex": {
                    "type": "number",
                    "required": true,
                    "description": "拖拽插入位置。",
                    "default": null
                },
                "isSuccess": {
                    "type": "boolean",
                    "required": true,
                    "description": "是否成功释放。",
                    "default": null
                }
            },
            "returns": null
        },
        "onScrollBarUpdate": {
            "description": "当前网格显示的起始位置item发生变化时触发，可通过该回调设置滚动条的位置及长度。",
            "params": {
                "index": {
                    "type": "number",
                    "required": true,
                    "description": "当前显示的网格起始位置的索引值。",
                    "default": null
                },
                "offset": {
                    "type": "number",
                    "required": true,
                    "description": "当前显示的网格起始位置元素相对网格显示起始位置的偏移，单位vp。",
                    "default": null
                }
            },
            "returns": {
                "type": "ComputedBarAttribute",
                "description": "滚动条的位置及长度。"
            }
        },
        "onReachStart": {
            "description": "网格到达起始位置时触发。",
            "params": {},
            "returns": null
        },
        "onReachEnd": {
            "description": "网格到达末尾位置时触发。",
            "params": {},
            "returns": null
        },
        "onScrollFrameBegin": {
            "description": "网格开始滑动时触发，事件参数传入即将发生的滑动量，事件处理函数中可根据应用场景计算实际需要的滑动量并作为事件处理函数的返回值返回，网格将按照返回值的实际滑动量进行滑动。",
            "params": {
                "offset": {
                    "type": "number",
                    "required": true,
                    "description": "即将发生的滑动量，单位vp。",
                    "default": null
                },
                "state": {
                    "type": "ScrollState",
                    "required": true,
                    "description": "当前滑动状态。",
                    "default": null
                }
            },
            "returns": {
                "type": "{ offsetRemain: number }",
                "description": "实际滑动量，单位vp。"
            }
        },
        "onScrollStart": {
            "description": "网格滑动开始时触发。手指拖动网格或网格的滚动条触发的滑动开始时，会触发该事件。使用Scroller滑动控制器触发的带动画的滑动，动画开始时会触发该事件。",
            "params": {},
            "returns": null
        },
        "onScrollStop": {
            "description": "网格滑动停止时触发。手指拖动网格或网格的滚动条触发的滑动，手指离开屏幕并且滑动停止时会触发该事件。使用Scroller滑动控制器触发的带动画的滑动，动画停止会触发该事件。",
            "params": {},
            "returns": null
        },
        "onScroll": {
            "description": "网格滑动时触发。",
            "params": {
                "scrollOffset": {
                    "type": "number",
                    "required": true,
                    "description": "每帧滚动的偏移量，Grid的内容向上滚动时偏移量为正，向下滚动时偏移量为负。单位vp。",
                    "default": null
                },
                "scrollState": {
                    "type": "ScrollState",
                    "required": true,
                    "description": "当前滑动状态。",
                    "default": null
                }
            },
            "returns": null
        }
    },
    "rules": null,
    "examples": [
        "/*\\n实现思路：\\n本示例展示了如何使用Grid组件的layoutDirection、maxCount、minCount、cellLength属性来控制网格的布局和显示。通过设置这些属性，可以灵活地调整网格的排列方式和显示数量。\\n\\n总体功能与效果描述：\\n- layoutDirection属性用于设置网格的布局方向。\\n- maxCount属性用于限制每行最多显示的网格项数量。\\n- minCount属性用于设置每行最少显示的网格项数量。\\n- cellLength属性用于设置网格单元的长度。\\n*/\\n\\n// GridExample.ets\\n@Entry\\n@Component\\nstruct GridExample {\\n  @State numbers: string[] = []\\n\\n  // 组件初始化时填充数据\\n  aboutToAppear() {\\n    for (let i = 1; i <= 30; i++) {\\n      this.numbers.push(i + '')\\n    }\\n  }\\n\\n  build() {\\n    Scroll() {\\n      Column({ space: 5 }) {\\n        Blank()\\n        Text('rowsTemplate、columnsTemplate都不设置layoutDirection、maxcount、minCount、cellLength才生效')\\n          .fontSize(15).fontColor(0xCCCCCC).width('90%')\\n        \\n        Grid() {\\n          ForEach(this.numbers, (day: string) => {\\n            GridItem() {\\n              Text(day).fontSize(16).backgroundColor(0xF9CF93)\\n            }.width(40).height(80).borderWidth(2).borderColor(Color.Red)\\n          }, (day: string) => day)\\n        }\\n        .height(300) // 设置网格高度\\n        .columnsGap(10) // 设置列间距\\n        .rowsGap(10) // 设置行间距\\n        .backgroundColor(0xFAEEE0) // 设置背景颜色\\n        .maxCount(6) // 设置每行最多显示6个网格项\\n        .minCount(2) // 设置每行最少显示2个网格项\\n        .cellLength(0) // 设置网格单元长度为0，表示不限制\\n        .layoutDirection(GridDirection.Row) // 设置网格布局方向为行优先\\n      }\\n      .width('90%').margin({ top: 5, left: 5, right: 5 })\\n      .align(Alignment.Center)\\n    }\\n  }\\n}",
        "/*\\n实现思路：\\n1. 使用@State装饰器管理Grid的列数和数据列表。\\n2. 在aboutToAppear生命周期函数中，从AppStorage中读取上次的列数设置。\\n3. 在build方法中，构建UI界面，包括一个文本提示和一个Grid组件。\\n4. Grid组件使用双指缩放手势来动态调整列数。\\n5. 通过PinchGesture的onActionEnd事件处理缩放结束时的逻辑，调整列数并保存到AppStorage。\\n总体功能与效果描述：\\n该示例展示了如何通过双指缩放手势动态调整Grid组件的列数，并在应用重启时恢复上次的列数设置。\\n*/\\n\\n// GridExample.ets\\n@Entry\\n@Component\\nstruct GridExample {\\n  @State numbers: String[] = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19']\\n  @State columns: number = 2\\n\\n  aboutToAppear() {\\n    let lastCount = AppStorage.get<number>('columnsCount')\\n    if (typeof lastCount != 'undefined') {\\n      this.columns = lastCount\\n    }\\n  }\\n\\n  build() {\\n    Column({ space: 5 }) {\\n      Row() {\\n        Text('双指缩放改变列数')\\n          .height('5%')\\n          .margin({ top: 10, left: 20 })\\n      }\\n\\n      Grid() {\\n        ForEach(this.numbers, (day: string) => {\\n          ForEach(this.numbers, (day: string) => {\\n            GridItem() {\\n              Text(day)\\n                .fontSize(16)\\n                .backgroundColor(0xF9CF93)\\n                .width('100%')\\n                .height(80)\\n                .textAlign(TextAlign.Center)\\n            }\\n          }, (day: string) => day)\\n        }, (day: string) => day)\\n      }\\n      .columnsTemplate('1fr '.repeat(this.columns))\\n      .columnsGap(10)\\n      .rowsGap(10)\\n      .width('90%')\\n      .scrollBar(BarState.Off)\\n      .backgroundColor(0xFAEEE0)\\n      .height('100%')\\n      .cachedCount(3)\\n\\n      .animation({\\n        duration: 300,\\n        curve: Curve.Smooth\\n      })\\n      .priorityGesture(\\n        PinchGesture()\\n          .onActionEnd((event: GestureEvent) => {\\n            console.info('end scale:' + event.scale)\\n\\n            if (event.scale > 2) {\\n              this.columns--\\n            } else if (event.scale < 0.6) {\\n              this.columns++\\n            }\\n\\n            this.columns = Math.min(4, Math.max(1, this.columns));\\n            AppStorage.setOrCreate<number>('columnsCount', this.columns)\\n          })\\n      )\\n    }.width('100%').margin({ top: 5 })\\n  }\\n}",
        "/*\\n实现思路：\\n本示例展示了如何在鸿蒙ArkUI中使用Grid组件实现拖拽排序功能。通过设置Grid的editMode属性为true，使Grid进入编辑模式，允许内部GridItem被拖拽。在onItemDragStart回调中设置拖拽过程中显示的图片，在onItemDrop回调中处理拖拽完成后的数据交换逻辑。\\n\\n总体功能与效果描述：\\n用户可以通过拖拽Grid中的GridItem来改变它们的排列顺序。拖拽过程中会显示一个自定义的拖拽图片，拖拽完成后，数据数组中的元素会根据新的位置进行交换。\\n*/\\n\\n// GridExample.ets\\n@Entry\\n@Component\\nstruct GridExample {\\n  @State numbers: string[] = [] // 存储GridItem显示的数字\\n  scroller: Scroller = new Scroller() // 用于Grid的滚动控制\\n  @State text: string = 'drag' // 拖拽过程中显示的文本\\n\\n  // 构建拖拽过程中显示的图片\\n  @Builder pixelMapBuilder() { \\n    Column() {\\n      Text(this.text)\\n        .fontSize(16)\\n        .backgroundColor(0xF9CF93)\\n        .width(80)\\n        .height(80)\\n        .textAlign(TextAlign.Center)\\n    }\\n  }\\n\\n  // 组件初始化时填充numbers数组\\n  aboutToAppear() {\\n    for (let i = 1; i <= 15; i++) {\\n      this.numbers.push(i + '')\\n    }\\n  }\\n\\n  // 交换数组中两个元素的位置\\n  changeIndex(index1: number, index2: number) { \\n    let temp: string;\\n    temp = this.numbers[index1];\\n    this.numbers[index1] = this.numbers[index2];\\n    this.numbers[index2] = temp;\\n  }\\n\\n  // 构建Grid组件\\n  build() {\\n    Column({ space: 5 }) {\\n      Grid(this.scroller) {\\n        ForEach(this.numbers, (day: string) => {\\n          GridItem() {\\n            Text(day)\\n              .fontSize(16)\\n              .backgroundColor(0xF9CF93)\\n              .width(80)\\n              .height(80)\\n              .textAlign(TextAlign.Center)\\n          }\\n        })\\n      }\\n      .columnsTemplate('1fr 1fr 1fr') // 设置列模板\\n      .columnsGap(10) // 设置列间距\\n      .rowsGap(10) // 设置行间距\\n      .width('90%') // 设置宽度\\n      .backgroundColor(0xFAEEE0) // 设置背景颜色\\n      .height(300) // 设置高度\\n      .editMode(true) // 设置Grid进入编辑模式\\n      .onItemDragStart((event: ItemDragInfo, itemIndex: number) => { \\n        this.text = this.numbers[itemIndex] // 设置拖拽过程中显示的文本\\n        return this.pixelMapBuilder() // 返回拖拽过程中显示的图片\\n      })\\n      .onItemDrop((event: ItemDragInfo, itemIndex: number, insertIndex: number, isSuccess: boolean) => { \\n        if (!isSuccess || insertIndex >= this.numbers.length) {\\n          return\\n        }\\n        console.info('beixiang' + itemIndex + '', insertIndex + '') \\n        this.changeIndex(itemIndex, insertIndex) // 交换数组中两个元素的位置\\n      })\\n    }.width('100%').margin({ top: 5 })\\n  }\\n}",
        "/*\\n实现思路：\\n本示例展示了如何在Grid组件中使用columnsTemplate属性，通过auto-fill、auto-fit和auto-stretch三种不同的方式来动态调整列的数量和宽度。\\n总体功能与效果描述：\\n通过三个不同的Grid示例，分别展示了auto-fill、auto-fit和auto-stretch的效果，使得用户可以根据不同的需求选择合适的列布局方式。\\n*/\\n\\n// GridColumnsTemplate.ets\\n@Entry\\n@Component\\nstruct GridColumnsTemplate {\\n  data: number[] = [0, 1, 2, 3, 4, 5]\\n  data1: number[] = [0, 1, 2, 3, 4, 5]\\n  data2: number[] = [0, 1, 2, 3, 4, 5]\\n\\n  build() {\\n    Column({ space: 10 }) {\\n      Text('auto-fill 根据设定的列宽自动计算列数').width('90%')\\n      // 使用auto-fill模式，根据设定的列宽自动计算列数\\n      Grid() {\\n        ForEach(this.data, (item: number) => {\\n          GridItem() {\\n            Text('N' + item).height(80)\\n          }\\n          .backgroundColor(Color.Orange)\\n        })\\n      }\\n      .width('90%')\\n      .border({ width: 1, color: Color.Black })\\n      .columnsTemplate('repeat(auto-fill, 70)') // 设置列模板为auto-fill，每列宽度为70\\n      .columnsGap(10) // 设置列间距\\n      .rowsGap(10) // 设置行间距\\n      .height(150)\\n\\n      Text('auto-fit 先根据设定的列宽计算列数，余下的空间会均分到每一列中').width('90%')\\n      // 使用auto-fit模式，先根据设定的列宽计算列数，余下的空间会均分到每一列中\\n      Grid() {\\n        ForEach(this.data1, (item: number) => {\\n          GridItem() {\\n            Text('N' + item).height(80)\\n          }\\n          .backgroundColor(Color.Orange)\\n        })\\n      }\\n      .width('90%')\\n      .border({ width: 1, color: Color.Black })\\n      .columnsTemplate('repeat(auto-fit, 70)') // 设置列模板为auto-fit，每列宽度为70\\n      .columnsGap(10) // 设置列间距\\n      .rowsGap(10) // 设置行间距\\n      .height(150)\\n\\n      Text('auto-stretch 先根据设定的列宽计算列数，余下的空间会均分到每个列间距中').width('90%')\\n      // 使用auto-stretch模式，先根据设定的列宽计算列数，余下的空间会均分到每个列间距中\\n      Grid() {\\n        ForEach(this.data2, (item: number) => {\\n          GridItem() {\\n            Text('N' + item).height(80)\\n          }\\n          .backgroundColor(Color.Orange)\\n        })\\n      }\\n      .width('90%')\\n      .border({ width: 1, color: Color.Black })\\n      .columnsTemplate('repeat(auto-stretch, 70)') // 设置列模板为auto-stretch，每列宽度为70\\n      .columnsGap(10) // 设置列间距\\n      .rowsGap(10) // 设置行间距\\n      .height(150)\\n    }\\n    .width('100%')\\n    .height('100%')\\n  }\\n}",
        "/*\\n实现思路：\\n本示例展示了如何使用GridLayoutOptions的irregularIndexes和onGetIrregularSizeByIndex属性来创建一个具有不规则大小的网格布局。通过设置不同的布局选项，可以实现不同的网格布局效果。\\n\\n总体功能与效果描述：\\n1. 第一个Grid组件使用layoutOptions1，其中设置了两个不规则索引，但未定义具体的不规则大小。\\n2. 第二个Grid组件使用layoutOptions2，其中不仅设置了不规则索引，还通过onGetIrregularSizeByIndex回调函数动态计算每个不规则索引的大小。\\n*/\\n\\n// GridExample.ets\\n@Entry\\n@Component\\nstruct GridExample {\\n  @State numbers: String[] = ['0', '1', '2', '3', '4']\\n  scroller: Scroller = new Scroller()\\n\\n  // 定义第一个网格布局选项，设置不规则索引但不定义具体大小\\n  layoutOptions1: GridLayoutOptions = {\\n    regularSize: [1, 1],        \\n    irregularIndexes: [0, 6],   \\n  }\\n\\n  // 定义第二个网格布局选项，设置不规则索引并通过回调函数定义具体大小\\n  layoutOptions2: GridLayoutOptions = {\\n    regularSize: [1, 1],\\n    irregularIndexes: [0, 7],   \\n    onGetIrregularSizeByIndex: (index: number) => {\\n      if (index === 0) {\\n        return [1, 5] // 第一个不规则索引的大小\\n      }\\n      return [1, index % 6 + 1] // 其他不规则索引的大小\\n    }\\n  }\\n\\n  build() {\\n    Column({ space: 5 }) {\\n      // 第一个Grid组件，使用layoutOptions1\\n      Grid(this.scroller, this.layoutOptions1) {\\n        ForEach(this.numbers, (day: string) => {\\n          ForEach(this.numbers, (day: string) => {\\n            GridItem() {\\n              Text(day)\\n                .fontSize(16)\\n                .backgroundColor(0xF9CF93)\\n                .width('100%')\\n                .height(80)\\n                .textAlign(TextAlign.Center)\\n            }.selectable(false)\\n          }, (day: string) => day)\\n        }, (day: string) => day)\\n      }\\n      .columnsTemplate('1fr 1fr 1fr 1fr 1fr')\\n      .columnsGap(10)\\n      .rowsGap(10)\\n      .multiSelectable(true)\\n      .scrollBar(BarState.Off)\\n      .width('90%')\\n      .backgroundColor(0xFAEEE0)\\n      .height(300)\\n\\n      Text('scroll').fontColor(0xCCCCCC).fontSize(9).width('90%')\\n\\n      // 第二个Grid组件，使用layoutOptions2\\n      Grid(undefined, this.layoutOptions2) {\\n        ForEach(this.numbers, (day: string) => {\\n          ForEach(this.numbers, (day: string) => {\\n            GridItem() {\\n              Text(day)\\n                .fontSize(16)\\n                .backgroundColor(0xF9CF93)\\n                .width('100%')\\n                .height(80)\\n                .textAlign(TextAlign.Center)\\n            }\\n          }, (day: string) => day)\\n        }, (day: string) => day)\\n      }\\n      .columnsTemplate('1fr 1fr 1fr 1fr 1fr')\\n      .columnsGap(10)\\n      .rowsGap(10)\\n      .scrollBar(BarState.Off)\\n      .width('90%')\\n      .backgroundColor(0xFAEEE0)\\n      .height(300)\\n    }.width('100%').margin({ top: 5 })\\n  }\\n}",
        "/*\\n实现思路：\\n本示例展示了如何使用鸿蒙ArkUI框架创建一个可滚动的网格组件。通过Grid组件和Scroller对象，实现了网格的滚动功能，并监听了滚动事件。\\n\\n总体功能与效果描述：\\n- 创建一个包含多个GridItem的网格组件。\\n- 设置网格的列模板、列间距、行间距等属性。\\n- 启用滚动交互，并设置滚动效果、滚动条样式。\\n- 监听滚动事件，如滚动开始、滚动停止、滚动到边缘等，并在控制台输出相关信息。\\n- 提供一个按钮，用于触发下一页的滚动。\\n*/\\n\\n// GridExample.ets\\n@Entry\\n@Component\\nstruct GridExample {\\n  @State numbers: String[] = ['0', '1', '2', '3', '4'] // 定义网格中显示的数字\\n  scroller: Scroller = new Scroller() // 创建一个Scroller对象，用于控制滚动\\n  @State gridPosition: number = 0 // 记录网格当前位置\\n\\n  build() {\\n    Column({ space: 5 }) {\\n      Text('scroll').fontColor(0xCCCCCC).fontSize(9).width('90%') // 显示一个文本标签\\n\\n      Grid(this.scroller) {\\n        ForEach(this.numbers, (day: string) => {\\n          ForEach(this.numbers, (day: string) => {\\n            GridItem() {\\n              Text(day)\\n                .fontSize(16)\\n                .backgroundColor(0xF9CF93)\\n                .width('100%')\\n                .height(80)\\n                .textAlign(TextAlign.Center)\\n            }\\n          }, (day: string) => day)\\n        }, (day: string) => day)\\n      }\\n      .columnsTemplate('1fr 1fr 1fr 1fr 1fr') // 设置网格的列模板\\n      .columnsGap(10) // 设置列间距\\n      .rowsGap(10) // 设置行间距\\n      .friction(0.6) // 设置滚动摩擦系数\\n      .enableScrollInteraction(true) // 启用滚动交互\\n      .supportAnimation(false) // 禁用滚动动画\\n      .multiSelectable(false) // 禁用多选\\n      .edgeEffect(EdgeEffect.Spring) // 设置边缘效果为弹性\\n      .scrollBar(BarState.On) // 显示滚动条\\n      .scrollBarColor(Color.Grey) // 设置滚动条颜色\\n      .scrollBarWidth(4) // 设置滚动条宽度\\n      .width('90%') // 设置网格宽度\\n      .backgroundColor(0xFAEEE0) // 设置背景颜色\\n      .height(300) // 设置网格高度\\n      .onScrollIndex((first: number, last: number) => {\\n        console.info(first.toString())\\n        console.info(last.toString())\\n      })\\n      .onScrollBarUpdate((index: number, offset: number) => {\\n        console.info(\"XXX\" + 'Grid onScrollBarUpdate,index : ' + index.toString() + \",offset\" + offset.toString())\\n        return { totalOffset: (index / 5) * (80 + 10) - offset, totalLength: 80 * 5 + 10 * 4 }\\n      })\\n      .onDidScroll((scrollOffset: number, scrollState: ScrollState) => {\\n        console.info(scrollOffset.toString())\\n        console.info(scrollState.toString())\\n      })\\n      .onScrollStart(() => {\\n        console.info(\"XXX\" + \"Grid onScrollStart\")\\n      })\\n      .onScrollStop(() => {\\n        console.info(\"XXX\" + \"Grid onScrollStop\")\\n      })\\n      .onReachStart(() => {\\n        this.gridPosition = 0\\n        console.info(\"XXX\" + \"Grid onReachStart\")\\n      })\\n      .onReachEnd(() => {\\n        this.gridPosition = 2\\n        console.info(\"XXX\" + \"Grid onReachEnd\")\\n      })\\n\\n      Button('next page')\\n        .onClick(() => { \\n          this.scroller.scrollPage({ next: true })\\n        })\\n    }.width('100%').margin({ top: 5 })\\n  }\\n}",
        "/*\\n实现思路：\\n本示例展示了如何使用Grid组件和GridLayoutOptions中的onGetRectByIndex属性来实现固定行列的Grid布局，并自定义每个GridItem的位置和大小。\\n总体功能与效果描述：\\n示例包含两个Grid布局，第一个Grid布局使用默认的行列模板，第二个Grid布局使用自定义的onGetRectByIndex属性来指定每个GridItem的位置和大小。\\n*/\\n\\n// GridExample.ets\\n@Entry\\n@Component\\nstruct GridExample {\\n  @State numbers1: String[] = ['0', '1', '2', '3', '4']\\n  @State numbers2: String[] = ['0', '1', '2', '3', '4', '5']\\n\\n  // 定义GridLayoutOptions，使用onGetRectByIndex方法自定义每个GridItem的位置和大小\\n  layoutOptions3: GridLayoutOptions = {\\n    regularSize: [1, 1],\\n    onGetRectByIndex: (index: number) => {\\n      if (index == 0)\\n        return [0, 0, 1, 1] // 第一个GridItem的位置和大小\\n      else if (index == 1)\\n        return [0, 1, 2, 2] // 第二个GridItem的位置和大小\\n      else if (index == 2)\\n        return [0, 3, 3, 3] // 第三个GridItem的位置和大小\\n      else if (index == 3)\\n        return [3, 0, 3, 3] // 第四个GridItem的位置和大小\\n      else if (index == 4)\\n        return [4, 3, 2, 2] // 第五个GridItem的位置和大小\\n      else\\n        return [5, 5, 1, 1] // 第六个GridItem的位置和大小\\n    }\\n  }\\n\\n  build() {\\n    Column({ space: 5 }) {\\n      // 第一个Grid布局，使用默认的行列模板\\n      Grid() {\\n        ForEach(this.numbers1, (day: string) => {\\n          ForEach(this.numbers1, (day: string) => {\\n            GridItem() {\\n              Text(day)\\n                .fontSize(16)\\n                .backgroundColor(0xF9CF93)\\n                .width('100%')\\n                .height('100%')\\n                .textAlign(TextAlign.Center)\\n            }\\n          }, (day: string) => day)\\n        }, (day: string) => day)\\n      }\\n      .columnsTemplate('1fr 1fr 1fr 1fr 1fr') // 定义列模板\\n      .rowsTemplate('1fr 1fr 1fr 1fr 1fr') // 定义行模板\\n      .columnsGap(10) // 列间距\\n      .rowsGap(10) // 行间距\\n      .width('90%')\\n      .backgroundColor(0xFAEEE0)\\n      .height(300)\\n\\n      Text('GridLayoutOptions的使用：onGetRectByIndex。').fontColor(0xCCCCCC).fontSize(9).width('90%')\\n\\n      // 第二个Grid布局，使用自定义的GridLayoutOptions\\n      Grid(undefined, this.layoutOptions3) {\\n        ForEach(this.numbers2, (day: string) => {\\n          GridItem() {\\n            Text(day)\\n              .fontSize(16)\\n              .backgroundColor(0xF9CF93)\\n              .width('100%')\\n              .height(\"100%\")\\n              .textAlign(TextAlign.Center)\\n          }\\n          .height(\"100%\")\\n          .width('100%')\\n        }, (day: string) => day)\\n      }\\n      .columnsTemplate('1fr 1fr 1fr 1fr 1fr 1fr') // 定义列模板\\n      .rowsTemplate('1fr 1fr 1fr 1fr 1fr 1fr') // 定义行模板\\n      .columnsGap(10) // 列间距\\n      .rowsGap(10) // 行间距\\n      .width('90%')\\n      .backgroundColor(0xFAEEE0)\\n      .height(300)\\n    }.width('100%').margin({ top: 5 })\\n  }\\n}",
        "/*\\n实现思路：\\n1. 创建一个包含多个组件的页面，包括头部、商品类型列表和数字列表。\\n2. 使用Grid和List组件来布局和展示数据。\\n3. 实现嵌套滚动功能，使得在滚动外部列表时，内部列表也能相应滚动。\\n4. 使用onScrollFrameBegin事件来控制滚动的细节，确保滚动效果平滑。\\n5. 提供一个按钮，用于快速返回页面顶部。\\n\\n总体功能与效果描述：\\n- 页面包含一个头部、商品类型列表和数字列表。\\n- 商品类型列表使用Grid组件展示，数字列表使用List组件展示。\\n- 实现嵌套滚动，外部列表滚动时，内部列表也能滚动。\\n- 使用onScrollFrameBegin事件处理滚动细节，确保滚动效果平滑。\\n- 提供一个按钮，点击后页面快速返回顶部。\\n*/\\n\\n// GridExample.ets\\n@Entry\\n@Component\\nstruct GridExample {\\n  @State colors: number[] = [0xFFC0CB, 0xDA70D6, 0x6B8E23, 0x6A5ACD, 0x00FFFF, 0x00FF7F]\\n  @State numbers: number[] = []\\n  @State translateY: number = 0\\n  private scroller: Scroller = new Scroller()\\n  private gridScroller: Scroller = new Scroller()\\n  private touchDown: boolean = false\\n  private listTouchDown: boolean = false\\n  private scrolling: boolean = false\\n\\n  // 初始化数据，生成100个数字\\n  aboutToAppear() {\\n    for (let i = 0; i < 100; i++) {\\n      this.numbers.push(i)\\n    }\\n  }\\n\\n  build() {\\n    Stack() {\\n      Column() {\\n        Row() {\\n          Text('Head')\\n        }\\n\\n        Column() {\\n          List({ scroller: this.scroller }) {\\n            ListItem() {\\n              Grid() {\\n                GridItem() {\\n                  Text('GoodsTypeList1')\\n                }\\n                .backgroundColor(this.colors[0])\\n                .columnStart(0)\\n                .columnEnd(1)\\n\\n                GridItem() {\\n                  Text('GoodsTypeList2')\\n                }\\n                .backgroundColor(this.colors[1])\\n                .columnStart(0)\\n                .columnEnd(1)\\n\\n                GridItem() {\\n                  Text('GoodsTypeList3')\\n                }\\n                .backgroundColor(this.colors[2])\\n                .columnStart(0)\\n                .columnEnd(1)\\n\\n                GridItem() {\\n                  Text('GoodsTypeList4')\\n                }\\n                .backgroundColor(this.colors[3])\\n                .columnStart(0)\\n                .columnEnd(1)\\n\\n                GridItem() {\\n                  Text('GoodsTypeList5')\\n                }\\n                .backgroundColor(this.colors[4])\\n                .columnStart(0)\\n                .columnEnd(1)\\n              }\\n              .scrollBar(BarState.Off)\\n              .columnsGap(15)\\n              .rowsGap(10)\\n              .rowsTemplate('1fr 1fr 1fr 1fr 1fr')\\n              .columnsTemplate('1fr')\\n              .width('100%')\\n              .height(200)\\n            }\\n\\n            ListItem() {\\n              Grid(this.gridScroller) {\\n                ForEach(this.numbers, (item: number) => {\\n                  GridItem() {\\n                    Text(item + '')\\n                      .fontSize(16)\\n                      .backgroundColor(0xF9CF93)\\n                      .width('100%')\\n                      .height('100%')\\n                      .textAlign(TextAlign.Center)\\n                  }\\n                  .width('100%')\\n                  .height(40)\\n                  .shadow({ radius: 10, color: '#909399', offsetX: 1, offsetY: 1 })\\n                  .borderRadius(10)\\n                  .translate({ x: 0, y: this.translateY })\\n                }, (item: string) => item)\\n              }\\n              .columnsTemplate('1fr 1fr')\\n              .friction(0.3)\\n              .columnsGap(15)\\n              .rowsGap(10)\\n              .scrollBar(BarState.Off)\\n              .width('100%')\\n              .height('100%')\\n              .layoutDirection(GridDirection.Column)\\n              .nestedScroll({\\n                scrollForward: NestedScrollMode.PARENT_FIRST,\\n                scrollBackward: NestedScrollMode.SELF_FIRST\\n              })\\n              .onTouch((event: TouchEvent) => {\\n                if (event.type == TouchType.Down) {\\n                  this.listTouchDown = true\\n                } else if (event.type == TouchType.Up) {\\n                  this.listTouchDown = false\\n                }\\n              })\\n            }\\n          }\\n          .scrollBar(BarState.Off)\\n          .edgeEffect(EdgeEffect.None)\\n          .onTouch((event: TouchEvent) => {\\n            if (event.type == TouchType.Down) {\\n              this.touchDown = true\\n            } else if (event.type == TouchType.Up) {\\n              this.touchDown = false\\n            }\\n          })\\n          .onScrollFrameBegin((offset: number, state: ScrollState) => {\\n            if (this.scrolling && offset > 0) {\\n              let newOffset = this.scroller.currentOffset().yOffset\\n              if (newOffset >= 590) {\\n                this.gridScroller.scrollBy(0, offset)\\n                return { offsetRemain: 0 }\\n              } else if (newOffset + offset > 590) {\\n                this.gridScroller.scrollBy(0, newOffset + offset - 590)\\n                return { offsetRemain: 590 - newOffset }\\n              }\\n            }\\n            return { offsetRemain: offset }\\n          })\\n          .onScrollStart(() => {\\n            if (this.touchDown && !this.listTouchDown) {\\n              this.scrolling = true\\n            }\\n          })\\n          .onScrollStop(() => {\\n            this.scrolling = false\\n          })\\n        }\\n        .width('100%')\\n        .height('100%')\\n        .padding({ left: 10, right: 10 })\\n      }\\n\\n      Row() {\\n        Text('Top')\\n          .width(30)\\n          .height(30)\\n          .borderRadius(50)\\n      }\\n      .padding(5)\\n      .borderRadius(50)\\n      .backgroundColor('#ffffff')\\n      .shadow({ radius: 10, color: '#909399', offsetX: 1, offsetY: 1 })\\n      .margin({ right: 22, bottom: 15 })\\n      .onClick(() => {\\n        this.scroller.scrollTo({ xOffset: 0, yOffset: 0 })\\n        this.gridScroller.scrollTo({ xOffset: 0, yOffset: 0 })\\n      })\\n    }\\n    .align(Alignment.BottomEnd)\\n  }\\n}"
    ],
    "is_common_attrs": true
}