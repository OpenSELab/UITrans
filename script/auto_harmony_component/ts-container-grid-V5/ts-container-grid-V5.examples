/*\n实现思路：\n本示例展示了如何使用Grid组件的layoutDirection、maxCount、minCount、cellLength属性来控制网格的布局和显示。通过设置这些属性，可以灵活地调整网格的排列方式和显示数量。\n\n总体功能与效果描述：\n- layoutDirection属性用于设置网格的布局方向。\n- maxCount属性用于限制每行最多显示的网格项数量。\n- minCount属性用于设置每行最少显示的网格项数量。\n- cellLength属性用于设置网格单元的长度。\n*/\n\n// GridExample.ets\n@Entry\n@Component\nstruct GridExample {\n  @State numbers: string[] = []\n\n  // 组件初始化时填充数据\n  aboutToAppear() {\n    for (let i = 1; i <= 30; i++) {\n      this.numbers.push(i + '')\n    }\n  }\n\n  build() {\n    Scroll() {\n      Column({ space: 5 }) {\n        Blank()\n        Text('rowsTemplate、columnsTemplate都不设置layoutDirection、maxcount、minCount、cellLength才生效')\n          .fontSize(15).fontColor(0xCCCCCC).width('90%')\n        \n        Grid() {\n          ForEach(this.numbers, (day: string) => {\n            GridItem() {\n              Text(day).fontSize(16).backgroundColor(0xF9CF93)\n            }.width(40).height(80).borderWidth(2).borderColor(Color.Red)\n          }, (day: string) => day)\n        }\n        .height(300) // 设置网格高度\n        .columnsGap(10) // 设置列间距\n        .rowsGap(10) // 设置行间距\n        .backgroundColor(0xFAEEE0) // 设置背景颜色\n        .maxCount(6) // 设置每行最多显示6个网格项\n        .minCount(2) // 设置每行最少显示2个网格项\n        .cellLength(0) // 设置网格单元长度为0，表示不限制\n        .layoutDirection(GridDirection.Row) // 设置网格布局方向为行优先\n      }\n      .width('90%').margin({ top: 5, left: 5, right: 5 })\n      .align(Alignment.Center)\n    }\n  }\n}


/*\n实现思路：\n1. 使用@State装饰器管理Grid的列数和数据列表。\n2. 在aboutToAppear生命周期函数中，从AppStorage中读取上次的列数设置。\n3. 在build方法中，构建UI界面，包括一个文本提示和一个Grid组件。\n4. Grid组件使用双指缩放手势来动态调整列数。\n5. 通过PinchGesture的onActionEnd事件处理缩放结束时的逻辑，调整列数并保存到AppStorage。\n总体功能与效果描述：\n该示例展示了如何通过双指缩放手势动态调整Grid组件的列数，并在应用重启时恢复上次的列数设置。\n*/\n\n// GridExample.ets\n@Entry\n@Component\nstruct GridExample {\n  @State numbers: String[] = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19']\n  @State columns: number = 2\n\n  aboutToAppear() {\n    let lastCount = AppStorage.get<number>('columnsCount')\n    if (typeof lastCount != 'undefined') {\n      this.columns = lastCount\n    }\n  }\n\n  build() {\n    Column({ space: 5 }) {\n      Row() {\n        Text('双指缩放改变列数')\n          .height('5%')\n          .margin({ top: 10, left: 20 })\n      }\n\n      Grid() {\n        ForEach(this.numbers, (day: string) => {\n          ForEach(this.numbers, (day: string) => {\n            GridItem() {\n              Text(day)\n                .fontSize(16)\n                .backgroundColor(0xF9CF93)\n                .width('100%')\n                .height(80)\n                .textAlign(TextAlign.Center)\n            }\n          }, (day: string) => day)\n        }, (day: string) => day)\n      }\n      .columnsTemplate('1fr '.repeat(this.columns))\n      .columnsGap(10)\n      .rowsGap(10)\n      .width('90%')\n      .scrollBar(BarState.Off)\n      .backgroundColor(0xFAEEE0)\n      .height('100%')\n      .cachedCount(3)\n\n      .animation({\n        duration: 300,\n        curve: Curve.Smooth\n      })\n      .priorityGesture(\n        PinchGesture()\n          .onActionEnd((event: GestureEvent) => {\n            console.info('end scale:' + event.scale)\n\n            if (event.scale > 2) {\n              this.columns--\n            } else if (event.scale < 0.6) {\n              this.columns++\n            }\n\n            this.columns = Math.min(4, Math.max(1, this.columns));\n            AppStorage.setOrCreate<number>('columnsCount', this.columns)\n          })\n      )\n    }.width('100%').margin({ top: 5 })\n  }\n}


/*\n实现思路：\n本示例展示了如何在鸿蒙ArkUI中使用Grid组件实现拖拽排序功能。通过设置Grid的editMode属性为true，使Grid进入编辑模式，允许内部GridItem被拖拽。在onItemDragStart回调中设置拖拽过程中显示的图片，在onItemDrop回调中处理拖拽完成后的数据交换逻辑。\n\n总体功能与效果描述：\n用户可以通过拖拽Grid中的GridItem来改变它们的排列顺序。拖拽过程中会显示一个自定义的拖拽图片，拖拽完成后，数据数组中的元素会根据新的位置进行交换。\n*/\n\n// GridExample.ets\n@Entry\n@Component\nstruct GridExample {\n  @State numbers: string[] = [] // 存储GridItem显示的数字\n  scroller: Scroller = new Scroller() // 用于Grid的滚动控制\n  @State text: string = 'drag' // 拖拽过程中显示的文本\n\n  // 构建拖拽过程中显示的图片\n  @Builder pixelMapBuilder() { \n    Column() {\n      Text(this.text)\n        .fontSize(16)\n        .backgroundColor(0xF9CF93)\n        .width(80)\n        .height(80)\n        .textAlign(TextAlign.Center)\n    }\n  }\n\n  // 组件初始化时填充numbers数组\n  aboutToAppear() {\n    for (let i = 1; i <= 15; i++) {\n      this.numbers.push(i + '')\n    }\n  }\n\n  // 交换数组中两个元素的位置\n  changeIndex(index1: number, index2: number) { \n    let temp: string;\n    temp = this.numbers[index1];\n    this.numbers[index1] = this.numbers[index2];\n    this.numbers[index2] = temp;\n  }\n\n  // 构建Grid组件\n  build() {\n    Column({ space: 5 }) {\n      Grid(this.scroller) {\n        ForEach(this.numbers, (day: string) => {\n          GridItem() {\n            Text(day)\n              .fontSize(16)\n              .backgroundColor(0xF9CF93)\n              .width(80)\n              .height(80)\n              .textAlign(TextAlign.Center)\n          }\n        })\n      }\n      .columnsTemplate('1fr 1fr 1fr') // 设置列模板\n      .columnsGap(10) // 设置列间距\n      .rowsGap(10) // 设置行间距\n      .width('90%') // 设置宽度\n      .backgroundColor(0xFAEEE0) // 设置背景颜色\n      .height(300) // 设置高度\n      .editMode(true) // 设置Grid进入编辑模式\n      .onItemDragStart((event: ItemDragInfo, itemIndex: number) => { \n        this.text = this.numbers[itemIndex] // 设置拖拽过程中显示的文本\n        return this.pixelMapBuilder() // 返回拖拽过程中显示的图片\n      })\n      .onItemDrop((event: ItemDragInfo, itemIndex: number, insertIndex: number, isSuccess: boolean) => { \n        if (!isSuccess || insertIndex >= this.numbers.length) {\n          return\n        }\n        console.info('beixiang' + itemIndex + '', insertIndex + '') \n        this.changeIndex(itemIndex, insertIndex) // 交换数组中两个元素的位置\n      })\n    }.width('100%').margin({ top: 5 })\n  }\n}


/*\n实现思路：\n本示例展示了如何在Grid组件中使用columnsTemplate属性，通过auto-fill、auto-fit和auto-stretch三种不同的方式来动态调整列的数量和宽度。\n总体功能与效果描述：\n通过三个不同的Grid示例，分别展示了auto-fill、auto-fit和auto-stretch的效果，使得用户可以根据不同的需求选择合适的列布局方式。\n*/\n\n// GridColumnsTemplate.ets\n@Entry\n@Component\nstruct GridColumnsTemplate {\n  data: number[] = [0, 1, 2, 3, 4, 5]\n  data1: number[] = [0, 1, 2, 3, 4, 5]\n  data2: number[] = [0, 1, 2, 3, 4, 5]\n\n  build() {\n    Column({ space: 10 }) {\n      Text('auto-fill 根据设定的列宽自动计算列数').width('90%')\n      // 使用auto-fill模式，根据设定的列宽自动计算列数\n      Grid() {\n        ForEach(this.data, (item: number) => {\n          GridItem() {\n            Text('N' + item).height(80)\n          }\n          .backgroundColor(Color.Orange)\n        })\n      }\n      .width('90%')\n      .border({ width: 1, color: Color.Black })\n      .columnsTemplate('repeat(auto-fill, 70)') // 设置列模板为auto-fill，每列宽度为70\n      .columnsGap(10) // 设置列间距\n      .rowsGap(10) // 设置行间距\n      .height(150)\n\n      Text('auto-fit 先根据设定的列宽计算列数，余下的空间会均分到每一列中').width('90%')\n      // 使用auto-fit模式，先根据设定的列宽计算列数，余下的空间会均分到每一列中\n      Grid() {\n        ForEach(this.data1, (item: number) => {\n          GridItem() {\n            Text('N' + item).height(80)\n          }\n          .backgroundColor(Color.Orange)\n        })\n      }\n      .width('90%')\n      .border({ width: 1, color: Color.Black })\n      .columnsTemplate('repeat(auto-fit, 70)') // 设置列模板为auto-fit，每列宽度为70\n      .columnsGap(10) // 设置列间距\n      .rowsGap(10) // 设置行间距\n      .height(150)\n\n      Text('auto-stretch 先根据设定的列宽计算列数，余下的空间会均分到每个列间距中').width('90%')\n      // 使用auto-stretch模式，先根据设定的列宽计算列数，余下的空间会均分到每个列间距中\n      Grid() {\n        ForEach(this.data2, (item: number) => {\n          GridItem() {\n            Text('N' + item).height(80)\n          }\n          .backgroundColor(Color.Orange)\n        })\n      }\n      .width('90%')\n      .border({ width: 1, color: Color.Black })\n      .columnsTemplate('repeat(auto-stretch, 70)') // 设置列模板为auto-stretch，每列宽度为70\n      .columnsGap(10) // 设置列间距\n      .rowsGap(10) // 设置行间距\n      .height(150)\n    }\n    .width('100%')\n    .height('100%')\n  }\n}


/*\n实现思路：\n本示例展示了如何使用GridLayoutOptions的irregularIndexes和onGetIrregularSizeByIndex属性来创建一个具有不规则大小的网格布局。通过设置不同的布局选项，可以实现不同的网格布局效果。\n\n总体功能与效果描述：\n1. 第一个Grid组件使用layoutOptions1，其中设置了两个不规则索引，但未定义具体的不规则大小。\n2. 第二个Grid组件使用layoutOptions2，其中不仅设置了不规则索引，还通过onGetIrregularSizeByIndex回调函数动态计算每个不规则索引的大小。\n*/\n\n// GridExample.ets\n@Entry\n@Component\nstruct GridExample {\n  @State numbers: String[] = ['0', '1', '2', '3', '4']\n  scroller: Scroller = new Scroller()\n\n  // 定义第一个网格布局选项，设置不规则索引但不定义具体大小\n  layoutOptions1: GridLayoutOptions = {\n    regularSize: [1, 1],        \n    irregularIndexes: [0, 6],   \n  }\n\n  // 定义第二个网格布局选项，设置不规则索引并通过回调函数定义具体大小\n  layoutOptions2: GridLayoutOptions = {\n    regularSize: [1, 1],\n    irregularIndexes: [0, 7],   \n    onGetIrregularSizeByIndex: (index: number) => {\n      if (index === 0) {\n        return [1, 5] // 第一个不规则索引的大小\n      }\n      return [1, index % 6 + 1] // 其他不规则索引的大小\n    }\n  }\n\n  build() {\n    Column({ space: 5 }) {\n      // 第一个Grid组件，使用layoutOptions1\n      Grid(this.scroller, this.layoutOptions1) {\n        ForEach(this.numbers, (day: string) => {\n          ForEach(this.numbers, (day: string) => {\n            GridItem() {\n              Text(day)\n                .fontSize(16)\n                .backgroundColor(0xF9CF93)\n                .width('100%')\n                .height(80)\n                .textAlign(TextAlign.Center)\n            }.selectable(false)\n          }, (day: string) => day)\n        }, (day: string) => day)\n      }\n      .columnsTemplate('1fr 1fr 1fr 1fr 1fr')\n      .columnsGap(10)\n      .rowsGap(10)\n      .multiSelectable(true)\n      .scrollBar(BarState.Off)\n      .width('90%')\n      .backgroundColor(0xFAEEE0)\n      .height(300)\n\n      Text('scroll').fontColor(0xCCCCCC).fontSize(9).width('90%')\n\n      // 第二个Grid组件，使用layoutOptions2\n      Grid(undefined, this.layoutOptions2) {\n        ForEach(this.numbers, (day: string) => {\n          ForEach(this.numbers, (day: string) => {\n            GridItem() {\n              Text(day)\n                .fontSize(16)\n                .backgroundColor(0xF9CF93)\n                .width('100%')\n                .height(80)\n                .textAlign(TextAlign.Center)\n            }\n          }, (day: string) => day)\n        }, (day: string) => day)\n      }\n      .columnsTemplate('1fr 1fr 1fr 1fr 1fr')\n      .columnsGap(10)\n      .rowsGap(10)\n      .scrollBar(BarState.Off)\n      .width('90%')\n      .backgroundColor(0xFAEEE0)\n      .height(300)\n    }.width('100%').margin({ top: 5 })\n  }\n}


/*\n实现思路：\n本示例展示了如何使用鸿蒙ArkUI框架创建一个可滚动的网格组件。通过Grid组件和Scroller对象，实现了网格的滚动功能，并监听了滚动事件。\n\n总体功能与效果描述：\n- 创建一个包含多个GridItem的网格组件。\n- 设置网格的列模板、列间距、行间距等属性。\n- 启用滚动交互，并设置滚动效果、滚动条样式。\n- 监听滚动事件，如滚动开始、滚动停止、滚动到边缘等，并在控制台输出相关信息。\n- 提供一个按钮，用于触发下一页的滚动。\n*/\n\n// GridExample.ets\n@Entry\n@Component\nstruct GridExample {\n  @State numbers: String[] = ['0', '1', '2', '3', '4'] // 定义网格中显示的数字\n  scroller: Scroller = new Scroller() // 创建一个Scroller对象，用于控制滚动\n  @State gridPosition: number = 0 // 记录网格当前位置\n\n  build() {\n    Column({ space: 5 }) {\n      Text('scroll').fontColor(0xCCCCCC).fontSize(9).width('90%') // 显示一个文本标签\n\n      Grid(this.scroller) {\n        ForEach(this.numbers, (day: string) => {\n          ForEach(this.numbers, (day: string) => {\n            GridItem() {\n              Text(day)\n                .fontSize(16)\n                .backgroundColor(0xF9CF93)\n                .width('100%')\n                .height(80)\n                .textAlign(TextAlign.Center)\n            }\n          }, (day: string) => day)\n        }, (day: string) => day)\n      }\n      .columnsTemplate('1fr 1fr 1fr 1fr 1fr') // 设置网格的列模板\n      .columnsGap(10) // 设置列间距\n      .rowsGap(10) // 设置行间距\n      .friction(0.6) // 设置滚动摩擦系数\n      .enableScrollInteraction(true) // 启用滚动交互\n      .supportAnimation(false) // 禁用滚动动画\n      .multiSelectable(false) // 禁用多选\n      .edgeEffect(EdgeEffect.Spring) // 设置边缘效果为弹性\n      .scrollBar(BarState.On) // 显示滚动条\n      .scrollBarColor(Color.Grey) // 设置滚动条颜色\n      .scrollBarWidth(4) // 设置滚动条宽度\n      .width('90%') // 设置网格宽度\n      .backgroundColor(0xFAEEE0) // 设置背景颜色\n      .height(300) // 设置网格高度\n      .onScrollIndex((first: number, last: number) => {\n        console.info(first.toString())\n        console.info(last.toString())\n      })\n      .onScrollBarUpdate((index: number, offset: number) => {\n        console.info("XXX" + 'Grid onScrollBarUpdate,index : ' + index.toString() + ",offset" + offset.toString())\n        return { totalOffset: (index / 5) * (80 + 10) - offset, totalLength: 80 * 5 + 10 * 4 }\n      })\n      .onDidScroll((scrollOffset: number, scrollState: ScrollState) => {\n        console.info(scrollOffset.toString())\n        console.info(scrollState.toString())\n      })\n      .onScrollStart(() => {\n        console.info("XXX" + "Grid onScrollStart")\n      })\n      .onScrollStop(() => {\n        console.info("XXX" + "Grid onScrollStop")\n      })\n      .onReachStart(() => {\n        this.gridPosition = 0\n        console.info("XXX" + "Grid onReachStart")\n      })\n      .onReachEnd(() => {\n        this.gridPosition = 2\n        console.info("XXX" + "Grid onReachEnd")\n      })\n\n      Button('next page')\n        .onClick(() => { \n          this.scroller.scrollPage({ next: true })\n        })\n    }.width('100%').margin({ top: 5 })\n  }\n}


/*\n实现思路：\n本示例展示了如何使用Grid组件和GridLayoutOptions中的onGetRectByIndex属性来实现固定行列的Grid布局，并自定义每个GridItem的位置和大小。\n总体功能与效果描述：\n示例包含两个Grid布局，第一个Grid布局使用默认的行列模板，第二个Grid布局使用自定义的onGetRectByIndex属性来指定每个GridItem的位置和大小。\n*/\n\n// GridExample.ets\n@Entry\n@Component\nstruct GridExample {\n  @State numbers1: String[] = ['0', '1', '2', '3', '4']\n  @State numbers2: String[] = ['0', '1', '2', '3', '4', '5']\n\n  // 定义GridLayoutOptions，使用onGetRectByIndex方法自定义每个GridItem的位置和大小\n  layoutOptions3: GridLayoutOptions = {\n    regularSize: [1, 1],\n    onGetRectByIndex: (index: number) => {\n      if (index == 0)\n        return [0, 0, 1, 1] // 第一个GridItem的位置和大小\n      else if (index == 1)\n        return [0, 1, 2, 2] // 第二个GridItem的位置和大小\n      else if (index == 2)\n        return [0, 3, 3, 3] // 第三个GridItem的位置和大小\n      else if (index == 3)\n        return [3, 0, 3, 3] // 第四个GridItem的位置和大小\n      else if (index == 4)\n        return [4, 3, 2, 2] // 第五个GridItem的位置和大小\n      else\n        return [5, 5, 1, 1] // 第六个GridItem的位置和大小\n    }\n  }\n\n  build() {\n    Column({ space: 5 }) {\n      // 第一个Grid布局，使用默认的行列模板\n      Grid() {\n        ForEach(this.numbers1, (day: string) => {\n          ForEach(this.numbers1, (day: string) => {\n            GridItem() {\n              Text(day)\n                .fontSize(16)\n                .backgroundColor(0xF9CF93)\n                .width('100%')\n                .height('100%')\n                .textAlign(TextAlign.Center)\n            }\n          }, (day: string) => day)\n        }, (day: string) => day)\n      }\n      .columnsTemplate('1fr 1fr 1fr 1fr 1fr') // 定义列模板\n      .rowsTemplate('1fr 1fr 1fr 1fr 1fr') // 定义行模板\n      .columnsGap(10) // 列间距\n      .rowsGap(10) // 行间距\n      .width('90%')\n      .backgroundColor(0xFAEEE0)\n      .height(300)\n\n      Text('GridLayoutOptions的使用：onGetRectByIndex。').fontColor(0xCCCCCC).fontSize(9).width('90%')\n\n      // 第二个Grid布局，使用自定义的GridLayoutOptions\n      Grid(undefined, this.layoutOptions3) {\n        ForEach(this.numbers2, (day: string) => {\n          GridItem() {\n            Text(day)\n              .fontSize(16)\n              .backgroundColor(0xF9CF93)\n              .width('100%')\n              .height("100%")\n              .textAlign(TextAlign.Center)\n          }\n          .height("100%")\n          .width('100%')\n        }, (day: string) => day)\n      }\n      .columnsTemplate('1fr 1fr 1fr 1fr 1fr 1fr') // 定义列模板\n      .rowsTemplate('1fr 1fr 1fr 1fr 1fr 1fr') // 定义行模板\n      .columnsGap(10) // 列间距\n      .rowsGap(10) // 行间距\n      .width('90%')\n      .backgroundColor(0xFAEEE0)\n      .height(300)\n    }.width('100%').margin({ top: 5 })\n  }\n}


/*\n实现思路：\n1. 创建一个包含多个组件的页面，包括头部、商品类型列表和数字列表。\n2. 使用Grid和List组件来布局和展示数据。\n3. 实现嵌套滚动功能，使得在滚动外部列表时，内部列表也能相应滚动。\n4. 使用onScrollFrameBegin事件来控制滚动的细节，确保滚动效果平滑。\n5. 提供一个按钮，用于快速返回页面顶部。\n\n总体功能与效果描述：\n- 页面包含一个头部、商品类型列表和数字列表。\n- 商品类型列表使用Grid组件展示，数字列表使用List组件展示。\n- 实现嵌套滚动，外部列表滚动时，内部列表也能滚动。\n- 使用onScrollFrameBegin事件处理滚动细节，确保滚动效果平滑。\n- 提供一个按钮，点击后页面快速返回顶部。\n*/\n\n// GridExample.ets\n@Entry\n@Component\nstruct GridExample {\n  @State colors: number[] = [0xFFC0CB, 0xDA70D6, 0x6B8E23, 0x6A5ACD, 0x00FFFF, 0x00FF7F]\n  @State numbers: number[] = []\n  @State translateY: number = 0\n  private scroller: Scroller = new Scroller()\n  private gridScroller: Scroller = new Scroller()\n  private touchDown: boolean = false\n  private listTouchDown: boolean = false\n  private scrolling: boolean = false\n\n  // 初始化数据，生成100个数字\n  aboutToAppear() {\n    for (let i = 0; i < 100; i++) {\n      this.numbers.push(i)\n    }\n  }\n\n  build() {\n    Stack() {\n      Column() {\n        Row() {\n          Text('Head')\n        }\n\n        Column() {\n          List({ scroller: this.scroller }) {\n            ListItem() {\n              Grid() {\n                GridItem() {\n                  Text('GoodsTypeList1')\n                }\n                .backgroundColor(this.colors[0])\n                .columnStart(0)\n                .columnEnd(1)\n\n                GridItem() {\n                  Text('GoodsTypeList2')\n                }\n                .backgroundColor(this.colors[1])\n                .columnStart(0)\n                .columnEnd(1)\n\n                GridItem() {\n                  Text('GoodsTypeList3')\n                }\n                .backgroundColor(this.colors[2])\n                .columnStart(0)\n                .columnEnd(1)\n\n                GridItem() {\n                  Text('GoodsTypeList4')\n                }\n                .backgroundColor(this.colors[3])\n                .columnStart(0)\n                .columnEnd(1)\n\n                GridItem() {\n                  Text('GoodsTypeList5')\n                }\n                .backgroundColor(this.colors[4])\n                .columnStart(0)\n                .columnEnd(1)\n              }\n              .scrollBar(BarState.Off)\n              .columnsGap(15)\n              .rowsGap(10)\n              .rowsTemplate('1fr 1fr 1fr 1fr 1fr')\n              .columnsTemplate('1fr')\n              .width('100%')\n              .height(200)\n            }\n\n            ListItem() {\n              Grid(this.gridScroller) {\n                ForEach(this.numbers, (item: number) => {\n                  GridItem() {\n                    Text(item + '')\n                      .fontSize(16)\n                      .backgroundColor(0xF9CF93)\n                      .width('100%')\n                      .height('100%')\n                      .textAlign(TextAlign.Center)\n                  }\n                  .width('100%')\n                  .height(40)\n                  .shadow({ radius: 10, color: '#909399', offsetX: 1, offsetY: 1 })\n                  .borderRadius(10)\n                  .translate({ x: 0, y: this.translateY })\n                }, (item: string) => item)\n              }\n              .columnsTemplate('1fr 1fr')\n              .friction(0.3)\n              .columnsGap(15)\n              .rowsGap(10)\n              .scrollBar(BarState.Off)\n              .width('100%')\n              .height('100%')\n              .layoutDirection(GridDirection.Column)\n              .nestedScroll({\n                scrollForward: NestedScrollMode.PARENT_FIRST,\n                scrollBackward: NestedScrollMode.SELF_FIRST\n              })\n              .onTouch((event: TouchEvent) => {\n                if (event.type == TouchType.Down) {\n                  this.listTouchDown = true\n                } else if (event.type == TouchType.Up) {\n                  this.listTouchDown = false\n                }\n              })\n            }\n          }\n          .scrollBar(BarState.Off)\n          .edgeEffect(EdgeEffect.None)\n          .onTouch((event: TouchEvent) => {\n            if (event.type == TouchType.Down) {\n              this.touchDown = true\n            } else if (event.type == TouchType.Up) {\n              this.touchDown = false\n            }\n          })\n          .onScrollFrameBegin((offset: number, state: ScrollState) => {\n            if (this.scrolling && offset > 0) {\n              let newOffset = this.scroller.currentOffset().yOffset\n              if (newOffset >= 590) {\n                this.gridScroller.scrollBy(0, offset)\n                return { offsetRemain: 0 }\n              } else if (newOffset + offset > 590) {\n                this.gridScroller.scrollBy(0, newOffset + offset - 590)\n                return { offsetRemain: 590 - newOffset }\n              }\n            }\n            return { offsetRemain: offset }\n          })\n          .onScrollStart(() => {\n            if (this.touchDown && !this.listTouchDown) {\n              this.scrolling = true\n            }\n          })\n          .onScrollStop(() => {\n            this.scrolling = false\n          })\n        }\n        .width('100%')\n        .height('100%')\n        .padding({ left: 10, right: 10 })\n      }\n\n      Row() {\n        Text('Top')\n          .width(30)\n          .height(30)\n          .borderRadius(50)\n      }\n      .padding(5)\n      .borderRadius(50)\n      .backgroundColor('#ffffff')\n      .shadow({ radius: 10, color: '#909399', offsetX: 1, offsetY: 1 })\n      .margin({ right: 22, bottom: 15 })\n      .onClick(() => {\n        this.scroller.scrollTo({ xOffset: 0, yOffset: 0 })\n        this.gridScroller.scrollTo({ xOffset: 0, yOffset: 0 })\n      })\n    }\n    .align(Alignment.BottomEnd)\n  }\n}